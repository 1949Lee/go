/*
 Navicat Premium Data Transfer

 Source Server         : AliyunMySQL
 Source Server Type    : MySQL
 Source Server Version : 50732
 Source Host           : rm-2zet44i534j5xmc669o.mysql.rds.aliyuncs.com:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50732
 File Encoding         : 65001

 Date: 13/09/2024 09:18:09
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `article_id` int(1) unsigned NOT NULL AUTO_INCREMENT COMMENT '文章id，自增',
  `article_ctg` int(1) unsigned DEFAULT NULL COMMENT '文章分类',
  `article_title` varchar(255) NOT NULL COMMENT '文章标题',
  `article_author` int(1) unsigned DEFAULT NULL COMMENT '文章作者ID，外键',
  `article_summary` varchar(255) DEFAULT NULL COMMENT '文章摘要',
  `article_content` text COMMENT '文章正文',
  `article_createtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '文章创建时间',
  `article_updatetime` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' ON UPDATE CURRENT_TIMESTAMP COMMENT '文章修改时间',
  PRIMARY KEY (`article_id`),
  KEY `fk_article_author` (`article_author`),
  KEY `fk_article_ctg` (`article_ctg`),
  FULLTEXT KEY `ft_index` (`article_title`,`article_summary`,`article_content`) /*!50100 WITH PARSER `ngram` */ ,
  CONSTRAINT `fk_article_author` FOREIGN KEY (`article_author`) REFERENCES `author` (`author_id`) ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT `fk_article_ctg` FOREIGN KEY (`article_ctg`) REFERENCES `category` (`ctg_id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8mb4 COMMENT='文章表：1、标签会存一组标签名字和标签id，都分别用逗号隔开 2、文章摘要用于显示文章简介';

-- ----------------------------
-- Records of article
-- ----------------------------
BEGIN;
INSERT INTO `article` VALUES (1, 3, 'lee-markdown 语法介绍', 1, '斜体和粗体和粗斜体使用 * 和 ** 和 *** 表示斜体和粗体。这是 斜体，这是 ', '### 斜体和粗体和粗斜体\n使用 \\* 和 \\*\\* 和 \\*\\*\\* 表示斜体和粗体。\n这是 *斜体*，这是 **粗体**，这是***粗斜体***\n\n### 删除线\n使用 \\~\\~ 表示删除线\n这是 ~~删除线~~，这是 ~~删除线+***粗斜体***~~\n\n### 外链接\n使用 \\[描述](链接地址) 为文字增加外链接。\n这是一个链接：[李佳轩的个人网站——***镜中之人***](https://www.jiaxuanlee.com)\n\n### 图像块\n使用\\!\\[图像描述](图像地址)来添加图像，一个图像一行。\n![`这里是一个上传的图片，可以使用其他***语法***`](//blogserver.jiaxuanlee.com/static/article-file/1/DOTA2.jpg)\n\n### 行内底色变色强调\n使用\\`表示行内底色变色强调。\n这是一个`行内底色变色强调。[李佳轩的个人网站——***镜中之人***](https://www.jiaxuanlee.com)`。\n\n### 多级标题\n使用一个或多个#然后跟一个空格来表示多级标题\n\n# 这是一个一级标题\n###### 这是一个六级标题，标题还可以跟一些简单语法法。`变色强调。***粗斜体***`\n\n### 无序列表\n使用 \\- 表示无序列表。\n下面是一个列表：\n- 第一项 还可以使用基础用法。`变色强调。***粗斜体***`\n    - 第一项二级 1\n        - 三级子列表 1\n        - 三级子列表 2\n     - 第一项二级 2 5个空格不足8（上面的三级的最低要求是8个）视为4，所以缩进1级，为2级菜单\n      - 第一项二级 3 6个空格不足8，视为4，所以缩进1级\n    - 第一项二级 4 4个空格\n    - 子列表的各项缩进的空格数为4，不足4（1、2、3）视为同级。4个空格表示缩进1级。建议按照tab4个空格来缩进\n- 第二项\n- 第三项\n敖德萨大\n\n### 自动有序列表\n使用 \\+ 表示自动有序列表。\n下面是一个列表：\n+ 第一项 还可以使用基础用法。`变色强调。***粗斜体***`\n    + 第一项二级 1\n        + 三级子列表 1\n            - 无序第一项\n            - 无序第二项\n        + 三级子列表 2\n     + 第一项二级 2 5个空格不足8（上面的三级的最低要求是8个）视为4，所以缩进1级，为2级菜单\n      + 第一项二级 3 6个空格不足8，视为4，所以缩进1级\n    + 第一项二级 4 4个空格\n    + 子列表的各项缩进的空格数为4，不足4（1、2、3）视为同级。4个空格表示缩进1级。建议按照tab4个空格来缩进\n+ 第二项\n+ 第三项\n敖德萨大\n\n### 文字引用\n> 这是一个文字引用块，下方是一个自动有序列表\n> + `[李佳轩的个人网站——***镜中之人***](https://www.jiaxuanlee.com)`\n> + 第二项\n> 普通文字\n> - 无序列表也可以\n\n### 颜色块\n使用>>>background-color:#afeeee;表示颜色块开始，三个大于号后面可以加style表达式\n>>>background-color:#afeeee;text-align:center;border-radius:8px;margin:20px 25px;padding:10px 0;box-shadow:0 8px 12px #ebedf0;font-size:20px;\n浮生若梦，为欢几何。\n>>>\n\n>>>background-color:#afeeee;border-radius:8px;margin:20px 25px;padding:10px 0;box-shadow:0 8px 12px #ebedf0;\n也可以写其他的语法\n+ a\n+ b\n+ abc\n    + `bcd`\n>>>\n\n### 代码块\n使用\\`\\`\\` javascript表示代码块。\n```go\npackage main\n\nimport (\n	\"fmt\"\n	\"regexp\"\n)\n\nfunc main() {\n	a := \">>> a dsada\"\n	re := regexp.MustCompile(`>+\\s*(.+)`)\n	fmt.Println(re.FindAllStringSubmatch(a, -1)[0][1])\n}\n```\n\n### check列表\n- [x] 选择项1\n- [] 选择项2\n    - [] 选择项2.1\n    - [] 选择项2.2\n- [] 选择项3\n\n### table\n普通\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n可合并的\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格:+2+: |\n| 单元格:-2-: | \n| 单元格 | 单元格 | 单元格 |\n\n### 小技巧\n+ 支持转义字符。可以使用转义符来表示符号本身的意思，否则，会认为使用了markdown的语法。\n    如：使用 \\\\* 表示`*`。\n+ 支持段落首行缩进2个汉字。用其他的每个段落的开始可以用一个tab键（四个空格）来表示缩进两个空格。如不没有，则不缩进。\n+ 换行就是换行。\n+ 支持表情 😂😇🙌💚💛👏😉💝💙💘💞💕💯🖤💜❤️😍😻💓😘😹😂😇😋💗💖😁😀🤞😲😄✌️😅😃😌👍😊🤗💋😽😽😚🤠😼😏😸👄😺😙😽😚🤠😼😏😸👄😺😙👌😎😆😛🙏🤝🤤😑😐😝🤑🙂😴😪😶🤡🙃😤😵😓👊😦😷🤐🤔🙄😥👻🤓😜🤒🙁😔😯☹️☠️😣😒😕😖😩😰😢😢😮😿🤧😫🤥😨😳💀👎😬😞🤕🤢😱😭😠😈👿💩🙀😟💔😧😀\n', '2017-07-20 18:19:16', '2021-11-01 14:27:10');
INSERT INTO `article` VALUES (2, 1, 'JavaScript 数据类型', 1, '数据类型缩进最新的 ECMAScript 标准定义了 8 种数据类型:1.7 种基本数据类型:', '### 数据类型\n    最新的 ECMAScript 标准定义了 8 种数据类型:\n    + 7 种基本数据类型:存在于内存的栈中\n        - Boolean\n        - Null\n        - Undefined\n        - Number\n        - [BigInt (ES2020)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)\n        - String\n        - [Symbol(ES2015) ](https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol)\n    + 引用类型：存在于内存的堆中。\n        - Object(Array、Class、Function等常见的数据结构都属于Object)\n\n> 在计算机科学中, 对象是指内存中的可以被`标识符`引用的一块区域（堆）。\n\n### 判断方法\n如何判断数据类型，有三种方法：\n    - Object.prototype.toString.call(a)(推荐)\n    - typeof/instanceof\n\n### 附录\n- [MDN-JavaScript 数据类型和数据结构](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)', '2017-07-27 15:44:34', '2017-07-27 15:44:34');
INSERT INTO `article` VALUES (3, 1, 'JavaScript 二进制 八进制 十六进制', 1, '整数可以用十进制（基数为10）、十六进制（基数为16）、八进制（基数为8', '整数可以用十进制（基数为10）、十六进制（基数为16）、八进制（基数为8）以及二进制（基数为2）表示。\n\n### 二进制\n    二进制整数以0b（或0B）开头，只能包含数字0和1。\n    `0b11, 0b0011, -0b11`二进制, 基数为2。\n\n### 八进制\n    八进制的整数以0（或0O、0o）开头。如果以0O、0o开头，后面只能包括数字0-7。如果以0开头，后是八进制数字序列(0~7)，如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。\n    `015,  0001, -0o77, 0O1`八进制, 基数为8，注意`081`相当于十进制的81，但是`0o81`会报错。\n\n### 十六进制\n    十六进制整数以0x（或0X）开头，可以包含数字（0-9）和字母 a~f 或 A~F。\n    `0x1123, 0x00111, -0xF1A7`十六进制, 基数为16或\"hex\"。', '2017-08-09 14:15:22', '2017-08-09 14:15:22');
INSERT INTO `article` VALUES (4, 1, 'JavaScript Number类型的浮点数详解', 1, '1 JavaScript中的Number类型缩进Number作为JavaScript中的基本数据类型之一。既可以', '### 1 JavaScript中的Number类型\n    [Number](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number)作为JavaScript中的基本数据类型之一。既可以表示整数，也可以表示小数。使用的是为[双精度IEEE 754 64位浮点类型](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)。\n\n### 2 精度丢失\n    什么叫浮点数的精度呢。精度应该是指小数点后的位数，当然这是我个人理解。那精度丢失又是什么。小数有精度丢失，整数也存在精度丢失，数学意义上的小数不是每个都能用二进制在有限位数内精确的表示，就比如0.1用二进制表示，是一个无限循环的数，这中无限的在计算机中无法完全存储（基本数据类型存储在内存的栈中有长度限制，8字节、4字节），所以按照标准的规定就会 `近似存储`。其实不用无限循环，只要有效位数超过限制，只能做`近似存储`。`近似存储`之后，精度就丢失了，就好像`1/3`在[双精度IEEE 754 64位浮点类型](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)中存储并不能存储为成`零点3，3的循环`，只能存储成`零点3，一共52个3`。少了后面`无数个 - 52`个3。自然就精度丢失了。下面举例说明一下js中的精度丢失。\n\n![1/10在js中的部分值](//blogserver.jiaxuanlee.com/static/article-file/4/1730070430.png)\n\n![0.1+0.2 !== 0.3](//blogserver.jiaxuanlee.com/static/article-file/4/1.png)\n\n    由此可以看出，0.1在js中是一个64位的数，0.2也是，这两个数据按照规则相加后，是一个新数。而[双精度IEEE 754 64位浮点类型](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)本身存储0.1、0.2就存在精度丢失，两数做加法又存在精度丢失，然后最后的结果自然会存在精度丢失。\n    至此，我并没有说到底为什么[双精度IEEE 754 64位浮点类型](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)存在精度丢失。我只是想说，我们常说的精度丢失似乎是个模糊的概念。比如上面例子中0.1+0.2的结果。有些人会认为0.1+0.2=0.30000000000000004，因为我在浏览器里的控制台加出来的结果就是0.30000000000000004。但是你用toPrecision控制精度之后，你会发现，这个结果，js还是存了很多位。因为这个结果，网上很多人说js的精度最大是16位、15位、17位。我觉得并不精确。因为按照数学的理解，我可以用toPrecision打印出最多100位。因为toPrecision方法最高支持到100位。\n    所以接下来讨论精度时，我说的是二进制的精度，特别说明的才是10进制的精度！！！\n\n### 3 [双精度IEEE 754 64位浮点类型](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)\n    这个标准很多语言都采用了，比如：go中的float64、c/c++/Java等中的double类型、python的float。所以都会存在精度丢失的问题。\n    先回顾一下10进制的科学计数法，`-123 = -1 \\* 1.23  * 10^2 `，即，1.23的小数点右移2位（乘一个10小数点移一位），符号为负。那么二进制的科学计数法中 `-110 = -1 \\* 1.10 * 2^2`。因为是二进制，所以乘一个2小数点移一位，这里乘了两个，所以1.10的小数点右移两位，符号为负。那么我们就用这种方式表示一个二进制数。也就是说，在写代码时，我们将变量a赋值成0.1。需要先将0.1转换成二进制，然后将二进制用上面的科学计数法表示，然后进行存储。以后的变量（浮点数）加、减、乘、除都以这中二进制的科学技术法进行操作。\n    所以[双精度IEEE 754 64位浮点类型](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)规范如下：\n![双精度IEEE 754 64位浮点类型二进制表示](//blogserver.jiaxuanlee.com/static/article-file/4/2.png)\n\n![64位8字节的各个部分](//blogserver.jiaxuanlee.com/static/article-file/4/3.png)\n\n    其中`***S***`表示符号（0正1负）为`***1***`位、`***E（不是小e）***`表示阶码域为`***11***`位、`***M***`表示尾数域为`***52***`位。一共`***64***`位。\n\n### 4 精度丢失的原因\n    `0.1 + 0.2 !== 0.3`发生有两个原因，一个是0.1本身的存储就发生了精度丢失，另一个是，0.1 + 0.2 的加法过程，对阶、和对结果的操作都发生了精度丢失。这里的精度丢失都是因为`双精度IEEE 754 64位浮点类型`做近似值时采取了四舍六入五留双(又称银行家算法)。\n\n#### 4.1 十进制的数的`双精度IEEE 754 64位浮点类型`存储：0.1的二进制表示\n    整数部分十进制转其它进制的套路都很熟了，也就是辗转相除法；但是小数部分的转换好像有点陌生，不过大概的套路和辗转相除法有点相似，只不过变成了乘法。\n+ 将小数部分乘2，得到的数值其整数部分作为当前位进行存储；\n+ 将上述得到的数值小数部分重复1步骤，直到小数部分为0；\n\n    计算过程如下：\n    0.1 \\* 2 = 0.2 取整数部分0，得到小数部分0.2，不为0，继续；整数部分0为二进制新一位。\n    0.2 \\* 2 = 0.4 取整数部分0，得到小数部分0.4，不为0，继续；整数部分0为二进制新一位。\n    0.4 \\* 2 = 0.8 取整数部分0，得到小数部分0.8，不为0，继续；整数部分0为二进制新一位。\n    0.8 \\* 2 = 1.6 取整数部分1，得到小数部分0.6，不为0，继续；整数部分1为二进制新一位。\n    0.6 \\* 2 = 1.2 取整数部分1，得到小数部分0.2，不为0，继续；整数部分1为二进制新一位。\n    0.2 \\* 2 = 0.4 取整数部分0，得到小数部分0.4，不为0，继续；整数部分0为二进制新一位。\n    0.4 \\* 2 = 0.8 取整数部分0，得到小数部分0.8，不为0，继续；整数部分0为二进制新一位。\n    0.8 \\* 2 = 1.6 取整数部分1，得到小数部分0.6，不为0，继续；整数部分1为二进制新一位。\n    0.6 \\* 2 = 1.2 取整数部分1，得到小数部分0.2，不为0，继续；整数部分1为二进制新一位。\n    0.2 \\* 2 = 0.4 取整数部分0，得到小数部分0.4，不为0，继续；整数部分0为二进制新一位。\n    0.4 \\* 2 = 0.8 取整数部分0，得到小数部分0.8，不为0，继续；整数部分0为二进制新一位。\n    0.8 \\* 2 = 1.6 取整数部分1，得到小数部分0.6，不为0，继续；整数部分1为二进制新一位。\n    ……然后你发现，开始循环了。😂\n\n    所以十进制的0.1转换成二进制是`0.0001 1001 1001的循环`。这尾数部分的长度远远超过了我们规定的52位！！那这个时候就需要一个类似10进制的`四舍五入`也就是我最一开始提到的近似存储。IEEE 754规定了几种舍入规则。默认的是四舍六入五留双(又称银行家算法)具体的怎舍入这里就不提了。舍入的目的是为了尽可能的使64位双精度浮点数转换成的十进制数接近原始的十进制10。比如上面1/10这个值采用`双精度IEEE 754 64位浮点类型`存储后在转换成十进制之后是`0.1000000000000000055511151231257827021181583404541015625`。和最初的0.1还是有偏差的，这就是舍入的缺点，所以造成了精度丢失。这里我们说完了JS中0.1+0.2 !== 0.3的第一个原因，那就是某些小数，存储的时候就已经精度丢失了（产生了偏差）。\n\n下面是一个十进制的小数转二进制的方法\n``` javascript\n    /**\n     * 将浮点数的小数部分转为二进制小数表示\n     * @param {number} f 浮点数\n     * @param {number} maxLength 小数最大长度\n     */\n    function decimalToBinary (f, maxLength = 57) {\n      let res = \'0.\'\n      let cur = 0 // 小数位\n      let decimal = f > 1 ? f - Math.floor(f) : f // 当前位对应的小数\n\n      while (cur < maxLength && decimal !== 0) {\n        cur++\n        let n = decimal * 2\n        let intNum = Math.floor(n) // 取整数部分\n        decimal = n - intNum // 去小数部分\n        res += intNum // 将整数位补充到对应位上\n      }\n\n      return res\n    }\n```\n#### 4.2 `双精度IEEE 754 64位浮点类型`的浮点数运算：加法，0.1+0.2\n    浮点数参与计算时，浮点数参与计算时，有一个步骤叫`对阶`，以加法为例，要把小的指数域转化为大的指数域，也就是左移小指数浮点数的小数点，一旦小数点左移，必然会把52位有效域的最右边的位给挤出去，这个时候挤出去的部分也会发生`舍入`。这就又会发生一次精度丢失。\n>>>border: 3px solid #afeeee;border-radius:8px;margin:5px 25px;padding:10px 0 10px 20px;box-shadow:0 8px 12px #ebedf0;\n    0.1初始值\n    0.1 转化为二进制：0.0 0011 0011 0011 0011 0011 0011 ... （0011循环）\n    e（阶码） = E - 1023 = -4;\n    M（尾数）= 1.1001100110011001100110011001100110011001100110011010 (52位)\n>>>\n\n>>>border: 3px solid #afeeee;border-radius:8px;margin:0 25px 20px;padding:10px 0 10px 20px;box-shadow:0 8px 12px #ebedf0;\n    0.2初始值\n    0.2 转化为二进制：0.0011 0011 0011 0011 0011 0011 0011 ... （0011循环）\n    e（阶码） = E - 1023  = -3; \n    M（尾数）= 1.1001100110011001100110011001100110011001100110011010 (52位)\n>>>\n\n    我们发现，e的值不一样，这时候需要`对阶` 要把0.1的M小数点左移一位，阶码e加1，变成了-3，所以就和0.2的阶码一致了。对阶之后，0.1的值为：\n>>>border: 3px solid #afeeee;border-radius:8px;margin:5px 25px;padding:10px 0 10px 20px;box-shadow:0 8px 12px #ebedf0;\n    0.1对阶后的值\n    e（阶码）= E - 1023  = -3;\n    M（尾数）= 0.1100110011001100110011001100110011001100110011001101 (52位)\n>>>\n\n    然后进行相加，结果如下：\n>>>border: 3px solid #afeeee;border-radius:8px;margin:5px 25px 20px;padding:10px 0 10px 20px;box-shadow:0 8px 12px #ebedf0;\n    0.1 + 0.2 的结果\n    e（阶码） = E - 1023 = -3; \n    M（尾数）= 10.0110011001100110011001100110011001100110011001100111 (52位)\n>>>\n\n    然后这个结果小数点需要左移一位，然后e（阶码）加1然后在转换成10进制，左移一位的话又要舍去，所以又发生了精度丢失。最终的加法运算的结果自然就会不准。\n\n### 5 计算机计算的本质\n    不管是整数int还是浮点float、double等，计算都是按照计算机中特定存储格式来进行的，无论加减乘除、无论语言。所以，0.1 + 0.2 !== 0.3本质上讲是因为0.3的`双精度IEEE 754 64位浮点类型`存储的那64位和0.1 + 0.2的结果的64位不一样，只有比较双方的64位的每一位一模一样，我们这个相等才会成立。\n\n### 6 特殊值\n`JS中最大值`\n    `Number.MAX_VALUE`：当符号位为0、指数取到1023、小数位全为1时，为可表示的最大值。1.79E+308或21024。比其大的数视为无穷大\n\n`JS中最小值`\n    `Number.MIN_VALUE`：当符号位为0、指数位全为0（表示非规格浮点数）、小数位仅最后一位为1时，为可表示的最小正值。大约是5e-324\n\n`JS中最大安全数`\n    `Number.MAX_SAFE_INTEGER`：9007199254740991或2^53 - 1，安全存储的意思是指能够准确区分两个不相同的值。\n    Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2\n    但是Number.MAX_SAFE_INTEGER * 2 !== Number.MAX_SAFE_INTEGER + 2。因为乘了2之后，e会+1。比较时64位中的尾数域虽然相同，但是指数域不相同。\n\n`JS中最小安全数`\n    `Number.MIN_SAFE_INTEGER`：-9007199254740991或-(2^53 - 1)。\n\n`JS中的非数字`\n    `Number.NaN`：表示“非数字”（Not-A-Number）。和 [NaN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)相同。\n\n`JS中Number.EPSILON`\n    `Number.EPSILON`：表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。其值接近于2.2204460492503130808472633361816E-16，或者 2-52。\n    可以用来测试是否浮点数预算结果和预期是否相等:`Math.abs(0.3 - (0.1 + 0.2)) < Number.EPSILON`。为true时表示0.3 - (0.1+0.2) ≈ 0（误差小于Number.EPSILON）。\n\n![Number.EPSILON的应用](//blogserver.jiaxuanlee.com/static/article-file/4/4.png)\n\n## 总结\n\n### JS中Number的存储\n    [Number](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number)作为JavaScript中的基本数据类型之一。既可以表示整数，也可以表示小数。背后采用的是[双精度IEEE 754 64位浮点类型](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)，很多语言都采用了，c/c++/Java等中的double类型、python的float。\n\n### [双精度IEEE 754 64位浮点类型](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)精度丢失的原因\n    双精度IEEE 754 64位浮点类型本身就精度丢失。\n    原因一：10进制浮点数的二进制表示的小数尾数超过52位，就会利用四舍六入五留双（银行家算法）来做`近似存储`。这个本身就精度丢失了，比如十进制的0.1存储完之后，表示的真实制偏大，`0.1000000000000000055511151231257827021181583404541015625`。\n    原因二：双精度IEEE 754 64位浮点类型在计算中需要在`对阶`，`加减乘除运算`时会左移小数点，会舍弃部分尾数位，所以精度丢失。\n\n### [双精度IEEE 754 64位浮点类型](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)的确切精度\n    [双精度IEEE 754 64位浮点类型](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)的精度最高到16位。\n    尾数部分一共占52位，加上固定的1，一共53位，可以有53个1。可以表示小数，也可以表示整数。因为尾数部分表示的是有效数字，指数部分只是小数点左移右移。\n    当53位的1做二进制的小数时（零点1，一共53个1），转化为10进制是`1 - 1 / 2^53`，求值后，有效数字是16位。（ 2^53 = 1.110223024625157e-16）。\n    当53位的1做二进制的整数时（一共53个1），转化为10进制大概是`2^53 - 1`，也就是最大安全数，有效数字是16位。\n    注意，上面的小数或整数是16位，但是不代表十进制的所有16位整数或小数点后的16位小数都能表示，超过上面两个值的十进制整数过小数，是无法精确表示的，所以才会存在安全数的概念。所以是最高到16位，因为无法覆盖16位的每一种情况。\n\n### 精度丢失的解决方案\n    浮点数运算，附上代码：\n```javascript\n    (function () {\n        var calc = {\n            /*\n            函数，加法函数，用来得到精确的加法结果  \n            说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。\n            参数：arg1：第一个加数；arg2第二个加数；d要保留的小数位数（可以不传此参数，如果不传则不处理小数位数）\n            调用：Calc.Add(arg1,arg2,d)  \n            返回值：两数相加的结果\n            */\n            Add: function (arg1, arg2) {\n                arg1 = arg1.toString(), arg2 = arg2.toString();\n                var arg1Arr = arg1.split(\".\"), arg2Arr = arg2.split(\".\"), d1 = arg1Arr.length == 2 ? arg1Arr[1] : \"\", d2 = arg2Arr.length == 2 ? arg2Arr[1] : \"\";\n                var maxLen = Math.max(d1.length, d2.length);\n                var m = Math.pow(10, maxLen);\n                var result = Number(((arg1 * m + arg2 * m) / m).toFixed(maxLen));\n                var d = arguments[2];\n                return typeof d === \"number\" ? Number((result).toFixed(d)) : result;\n            },\n            /*\n            函数：减法函数，用来得到精确的减法结果  \n            说明：函数返回较为精确的减法结果。 \n            参数：arg1：第一个加数；arg2第二个加数；d要保留的小数位数（可以不传此参数，如果不传则不处理小数位数\n            调用：Calc.Sub(arg1,arg2)  \n            返回值：两数相减的结果\n            */\n            Sub: function (arg1, arg2) {\n                return Calc.Add(arg1, -Number(arg2), arguments[2]);\n            },\n            /*\n            函数：乘法函数，用来得到精确的乘法结果  \n            说明：函数返回较为精确的乘法结果。 \n            参数：arg1：第一个乘数；arg2第二个乘数；d要保留的小数位数（可以不传此参数，如果不传则不处理小数位数)\n            调用：Calc.Mul(arg1,arg2)  \n            返回值：两数相乘的结果\n            */\n            Mul: function (arg1, arg2) {\n                var r1 = arg1.toString(), r2 = arg2.toString(), m, resultVal, d = arguments[2];\n                m = (r1.split(\".\")[1] ? r1.split(\".\")[1].length : 0) + (r2.split(\".\")[1] ? r2.split(\".\")[1].length : 0);\n                resultVal = Number(r1.replace(\".\", \"\")) * Number(r2.replace(\".\", \"\")) / Math.pow(10, m);\n                return typeof d !== \"number\" ? Number(resultVal) : Number(resultVal.toFixed(parseInt(d)));\n            },\n            /*\n            函数：除法函数，用来得到精确的除法结果  \n            说明：函数返回较为精确的除法结果。 \n            参数：arg1：除数；arg2被除数；d要保留的小数位数（可以不传此参数，如果不传则不处理小数位数)\n            调用：Calc.Div(arg1,arg2)  \n            返回值：arg1除于arg2的结果\n            */\n            Div: function (arg1, arg2) {\n                var r1 = arg1.toString(), r2 = arg2.toString(), m, resultVal, d = arguments[2];\n                m = (r2.split(\".\")[1] ? r2.split(\".\")[1].length : 0) - (r1.split(\".\")[1] ? r1.split(\".\")[1].length : 0);\n                resultVal = Number(r1.replace(\".\", \"\")) / Number(r2.replace(\".\", \"\")) * Math.pow(10, m);\n                return typeof d !== \"number\" ? Number(resultVal) : Number(resultVal.toFixed(parseInt(d)));\n            }\n        };\n        window.Calc = calc;\n    }());\n```\n\n    浮点数比较的话，可以使用上面提到的Number.EPSILON，`Math.abs(x - y) < Number.EPSILON`，为true时表示x和y相等。\n\n### 参考\n- [Floating-point arithmetic](https://en.wikipedia.org/wiki/Floating-point_arithmetic)\n- [Double-precision floating-point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)\n- [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)\n- [四舍六入五留双（银行家算法）](https://en.wikipedia.org/wiki/Rounding)\n- [详解js中0.1+0.2!=0.3](https://zhuanlan.zhihu.com/p/95318421)\n- [JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)\n- [JS浮点数及精度问题](https://note.xiexuefeng.cc/post/js-float/)\n- [浮点数和JavaScript的Number](https://www.dazhuanlan.com/2019/10/15/5da55ba70adf6/)\n- [该死的IEEE-754浮点数，说「约」就「约」，你的底线呢？以JS的名义来好好查查你](https://segmentfault.com/a/1190000009084877)\n- [IEEE754 浮点数格式 与 Javascript number 的特性](https://segmentfault.com/a/1190000008268668)\n- [IEEE754数据格式介绍和解析方式（超权威）](https://blog.csdn.net/crjmail/article/details/79723051)\n- [IEEE754 浮点数的表示方法](https://blog.csdn.net/k346k346/article/details/50487127)\n- [MDN-Number.MAX_SAFE_INTEGER](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\n- [MDN-Number.prototype.toPrecision()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision)\n- [JS基础测试47期](https://github.com/zhangxinxu/quiz/issues/74)\n- [浮点数运算不精准的解决办法](https://ruiwenruiwen.github.io/2017/09/20/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E4%B8%8D%E7%B2%BE%E5%87%86%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/)', '2017-08-11 14:02:42', '2021-11-01 14:26:22');
INSERT INTO `article` VALUES (5, 1, 'JavaScript 热门冷门知识点', 1, '❤️全局isFinite()和Number.isFinite()缩进全局isFinite()和Number.isFinite()，都可以用', '### ❤️全局isFinite()和Number.isFinite()\n    全局isFinite()和Number.isFinite()，都可以用来检测一个数是否是有穷数（无穷大和无穷小之间）。\n    如果参数是 NaN，正无穷大或者负无穷大，二者都会返回false。\n    不同的是，全局isFinite()在入参不是数值的情况下会转换成数值；而Number.isFinite()的参数如果不是数值，会直接返回false。\n\n    代码示例：\n```javascript\n    Number.isFinite(Infinity);  // false\n    Number.isFinite(NaN);       // false\n    Number.isFinite(-Infinity); // false\n\n    Number.isFinite(0);         // true\n    Number.isFinite(2e64);      // true\n\n    Number.isFinite(\'0\');       // false, 全局函数 isFinite(\'0\') 会返回 true\n```\n\n### ❤️NaN和全局isNaN()和Number.isNaN()\n\n#### NaN\n    即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。\n    - 0 除以0会返回NaN —— 但是其他数除以0则不会返回NaN。\n        - `1/0`返回无穷，`0/0`返回NaN。\n    - 任何涉及 NaN 的操作(例如 NaN/10)都会返回 NaN\n    - NaN 与任何值都不相等，包括 NaN 本身。比如：`NaN == NaN`和` NaN === NaN`都会返回false。\n\n#### isNaN()\n    isNaN() 函数用来确定一个值是否为NaN 。\n    参数不是Number类型，将会执行Number()转换，将参数转换为数值后，在判断其是不是NaN。这也就是说，那些被Number转换后为NaN的值，调用全局isNaN()之后，才会返回true。而那些被Number转换后为数值类型的值，调用全局isNaN()之后，才会返回false。\n    例子如下：\n    ```javascript\n    isNaN(NaN);       // true\n    isNaN(undefined); // true\n    isNaN({});        // true\n\n    isNaN(true);      // false\n    isNaN(null);      // false\n    isNaN(37);        // false\n\n    // strings\n    isNaN(\"37\");      // false: 可以被转换成数值37\n    isNaN(\"37.37\");   // false: 可以被转换成数值37.37\n    isNaN(\"37,5\");    // true\n    isNaN(\'123ABC\');  // true:  parseInt(\"123ABC\")的结果是 123, 但是Number(\"123ABC\")结果是 NaN\n    isNaN(\"\");        // false: 空字符串被转换成0\n    isNaN(\" \");       // false: 包含空格的字符串被转换成0\n\n    // dates\n    isNaN(new Date());                // false\n    isNaN(new Date().toString());     // true\n\n    isNaN(\"blabla\")   // true: \"blabla\"不能转换成数值，转换成数值失败， 返回NaN\n    ```\n    注意，这个特性有一种应用，如果一个值需要进行运算（加减乘除等）。那么可以用全局的isNaN()来判断，返回false时，表示该值是否可以直接用来运算。因为非数值类型的值在进行运算的时候，会自动执行Number()转换，转换后返回NaN则表示失败。而isNaN对于非数值会进行Number()转换，所以，比较方便。\n全局isNaN的一种实现：\n```javascript\n    var isNaN = function(value) {\n        var n = Number(value);\n        return n !== n;\n    };\n```\n#### Number.isNaN()\n    和全局函数 isNaN() 相比，Number.isNaN() 不会自行将参数转换成数字，只有在参数是值为 NaN 的数字时，才会返回 true。它是比全局 isNaN() 的更稳妥的版本。\n\n### ❤️类型转换，非数值转换数值\n    因为JS中Number类型有整数和浮点，所以。这里列举了能够转换为整数或者浮点数的一共四中方法。\n\n#### 一元+操作符和Number()\n    Number和一元加操作符规则一致。\n    一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响，如下面的例子所示：`var num = 25;num = +num; // 仍然是 25不过`，在对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换。换句话说，布尔值 false 和 true 将被转换为 0 和 1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的 valueOf()和（或） toString()方法，再转换得到的值。\n    具体规则如下：\n    - 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。  如果是数字值，只是简单的传入和返回。\n    - 如果是 null 值，返回 0。\n    - 如果是 undefined，返回 NaN。\n    - 如果是字符串，遵循下列规则:\n        - 如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值，即\"1\" 会变成 1，\"123\"会变成 123，而\"011\"会变成 11(注意:前导的零被忽略了);\n        - 如果字符串中包含有效的浮点格式，如\"1.1\"，则将其转换为对应的浮点数值(同样，也会忽 略前导零);\n        - 如果字符串中包含有效的十六进制格式，例如\"0xf\"，则将其转换为相同大小的十进制整 数值;\n        - 如果字符串是空的(不包含任何字符)，则将其转换为 0;\n        - 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。\n    - 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。\n\n#### parseInt/parseFloat\n    parseInt/parseFloat:最多传两个参数，第二个参数表示进制。第二个参数不传时。ES5会忽略前导0、ES3中前导0会当八进制。\n    具体规则如下：\n    - 如果是Boolean、null、undefined、Object等非字符串或者非数值类型的值返回NaN\n    - 如果是字符串，遵循下列规则:就是从字符串开头，直接取第一位有效的非空格字符。直到不符合int或者float为止。\n        - 忽略字符串前面的空格，直至找到第一个非空格字符，直到解析完所有后续字符或者遇到了 一个非数字字符。\n        - 如果第一个非空格字符不是数字字符或者正负号，返回 NaN。（空串或者一个或多个空格都会返回NaN）。\n     - parseFloat()始终都会忽略前导的零。\n```javascript\n    // parseInt\n    var num1 = parseInt(\"1234blue\");// 1234\n    var num2 = parseInt(\"\");// NaN\n    var num3 = parseInt(\"0xA\");// 10(十六进制数)\n    var num4 = parseInt(22.5);// 22\n    var num5 = parseInt(\"070\");// ES3为56(八进制数)、ES5为70\n    var num6 = parseInt(\"70\");// 70(十进制数)\n    var num7 = parseInt(\"0xf\");// 15(十六进制数)\n\n    // parseFloat\n    var num1 = parseFloat(\"1234blue\");//1234 (整数)\n    var num2 = parseFloat(\"0xA\");//0\n    var num3 = parseFloat(\"22.5\");//22.5\n    var num4 = parseFloat(\"22.34.5\");//22.34\n    var num5 = parseFloat(\"0908.5\");//908.5\n    var num6 = parseFloat(\"3.125e7\");//31250000\n```\n\n### ❤️递增（i++）和递减(i--)\n    递增（i++）和递减(i--)操作符遵循下列规则：\n    + 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。\n    + 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN。字符串变量变成数值变量。\n    + 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。\n    + 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。\n    + 在应用于浮点数值时，执行加减 1 的操作。\n    + 在应用于对象时，先调用对象的 valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString()方法后再应用前述规则。对象变量变成数值变量。\n\n### ❤️逻辑非模拟boolean类型转换。\n    逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟 Boolean()转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。\n```javascript\n    alert(!!\"blue\"); //true\n    alert(!!0); //false\n    alert(!!NaN); //false\n    alert(!!\"\"); //false\n    alert(!!12345); //true\n```\n\n### ❤️逻辑与及应用\n    逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：\n    + 如果第一个操作数是对象或空串，则返回第二个操作数；\n    + 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；\n    + 如果两个操作数都是对象，则返回第二个操作数；\n    + 如果第一个操作数是 null，则返回 null；\n    + 如果第一个操作数是 NaN，则返回 NaN；\n    + 如果第一个操作数是 undefined，则返回 undefined。\n    + 如果第一个操作数是 空串，则返回 空串。\n\n    逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，则无论第二个操作数是什么值，结果都不再可能是true 了。\n    来看下面的例子：\n```javascript\n    var found = true;\n    var result = (found && someUndefinedVariable); // 这里会发生错误\n    alert(result); // 这一行不会执行\n````\n    在上面的代码中，当执行逻辑与操作时会发生错误，因为变量 someUndefinedVariable 没有声明。由于变量 found 的值是 true，所以逻辑与操作符会继续对变量 someUndefinedVariable 求值。但 someUndefinedVariable 尚未定义，因此就会导致错误。这说明不能在逻辑与操作中使用未定义的值。\n    如果像下面这个例中一样，将 found 的值设置为 false，就不会发生错误了：\n```javascript\n    var found = false;var result = (found && someUndefinedVariable); // 不会发生错误\n    alert(result); // 会执行（ \"false\"）\n```\n   所以逻辑与有这样的应用，用于判断一个对象存在，且，对象的某个字段为true或者为其他值：\n```javascript\n    if (data&&data.files&&data.files.length > 2) {\n        // data存在并且data的files字段存在且data.files的长度大于2时，if判断会成立。\n    }\n```\n\n### ❤️逻辑或及应用\n    逻辑或与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：\n    - 如果第一个操作数是对象或空串，则返回第一个操作数；\n    - 如果第一个操作数的求值结果为 false，则返回第二个操作数；\n    - 如果两个操作数都是对象，则返回第一个操作数；\n    - 如果两个操作数都是 null，则返回 null；\n    - 如果两个操作数都是 NaN，则返回 NaN；\n    - 如果两个操作数都是 undefined，则返回 undefined。\n\n    与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。下面看一个例子：\n```javascript\n    var found = true;var result = (found || someUndefinedVariable); // 不会发生错误\n    alert(result); // 会执行（ \"true\"）\n```\n    这个例子跟前面的例子一样，变量 someUndefinedVariable 也没有定义。但是，由于变量 found的值是 true，而变量 someUndefinedVariable 永远不会被求值，因此结果就会输出\"true\"。\n    如果像下面这个例子一样，把 found 的值改为 false，就会导致错误：\n```javascript\n    var found = false;var result = (found || someUndefinedVariable); // 这里会发生错误\n    alert(result); // 这一行不会执行\n```\n    我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。例如：\n```javascript\n    var myObject = preferredObject || backupObject;\n```\n    在这个例子中，变量 myObject 将被赋予等号后面两个值中的一个。变量 preferredObject 中包含优先赋给变量 myObject 的值，变量 backupObject 负责在 preferredObject 中不包含有效值的情况下提供后备值。如果 preferredObject 的值不是 null，那么它的值将被赋给 myObject；如果是 null，则将 backupObject 的值赋给 myObject。 \n    ECMAScript 程序的赋值语句经常会使用这种模式。\n\n### ❤️相等和不相等操作符的转化规则\n    在转换不同的数据类型时，遵循下列基本规则：\n    - Symbol类型是不会转换的。\n    - 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而true 转换为 1；\n    - 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值，转换方法使用Number转换而不是parseInt；\n    - 如果一个操作数是对象，另一个操作数是字符串或者数值或者布尔值（布尔值会转换为数值，见第一条规则），则调用对象的 valueOf()或toString方法，两个方方同时存在时，优先调用valueOf，用得到的基本类型值按照前面的规则进行比较；这两个操作符在进行比较时则要遵循下列规则。\n    - null 和 undefined 是相等的。要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。\n    - 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则， NaN 不等于 NaN。\n    - 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false。\n    - \\[] == \\!\\[] // true\n        - 首先，我们需要知道 ! 优先级是高于 ==;\n        - ![] 引用类型转换成布尔值都是true,因此![]的是false\n        - 根据上面的比较方法，其中一方是 boolean，将 boolean 转为 number 再进行判断，false转换成 number，对应的值是 0.\n        - 根据上面比较方法，有一方是 number，那么将object也转换成Number,空数组转换成数字，对应的值是0.(空数组转换成数字，对应的值是0，如果数组中只有一个数字，那么转成number就是这个数字，其它情况，均为NaN)\n        - 0 == 0; 为true\n\n### ❤️逗号操作符用于赋值。\n    逗号操作符还可以用于赋值在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示：\n    var num = (5, 1, 4, 8, 0); // num 的值为 0由于 0 是表达式中的最后一项，因此 num 的值就是 0。\n\n### ❤️函数参数传递都是值传递。\n    ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。对象、数组、类、这些之所以在函数内改变，是因为他们本身就是引用。传递的时候也是传递的引用本身，而不是引用所指向的值。\n\n### ❤️比较运算符\n```javascript\n    var result = \"a\" < 3; // false。\n```\n    因为\"a\"被转换成了 NaN由于字母\"a\"不能转换成合理的数值，因此就被转换成了 NaN。根据规则，任何操作数与 NaN 进行关系比较，结果都是 false。\n    于是，就出现了下面这个有意思的现象：\n```javascript\n    var result1 = NaN < 3; //false\n    var result2 = NaN >= 3; //false\n```\n    按照常理，如果一个值不小于另一个值，则一定是大于或等于那个值。然而，在与 NaN 进行比较时，这两个比较操作的结果都返回了 false。\n\n### ❤️void 运算符\n    - void 运算符 对给定的表达式进行求值，然后返回 undefined。即无论表达式是何种表达式、表达式是和值，void都会返回undefined。\n    - void 可以用来当做undefined。比如判断一个值是不是undefined的的时候:`if(a === void 0)`和`if(a === undefined)`是一样的。因为undefined不是[关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Reserved_Words)，也不是[保留字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Reserved_Words)。\n    - 立即调用的函数表达式，可以利用void会立即求表达式的值的特性，来构建立即调用的函数表达式（立即调用函数、自调用函数）\n        ```js\n        void function iife() {\n          console.log(\'执行了\');\n          return 1 // 不会返回1，会返回undefined，因为是通过void调用。\n        }();\n        // 原来的方式\n        (function iife() {\n          console.log(\'执行了\');\n          return 1 // 会返回1。\n        })()\n        ```\n    参考以下文章\n    - [MDN-void 运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void)\n    - [MDN-undefined](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)\n\n### ❤️运算符优先级\n[MDN-运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n\n### ❤️typeof和instanceof\n\n#### typeof检测函数\n    使用 typeof 操作符检测函数时，该操作符会返回\"function\"。在 Safari 5 及之前版本和 Chrome 7 及之前版本中使用 typeof 检测正则表达式时，由于规范的原因，这个操作符也返回\"function\"。 ECMA-262 规定任何在内部实现[[Call]]方法的对象都应该在应用 typeof 操作符时返回\"function\"。由于上述浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用 typeof 会返回\"function\"。在IE 和 Firefox 中，对正则表达式应用 typeof 会返回\"object\"。\n以下特殊返回需要注意：\n```javascript\ntypeof NaN === \'number\'; // 尽管它是 \"Not-A-Number\" (非数值) 的缩写\n\ntypeof function() {} === \'function\';\ntypeof class C {} === \'function\'\n```\n\n    参考：\n    - [MDN-typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)\n\n#### instanceof\n    [instanceof和typeof原理](https://juejin.im/post/5b0b9b9051882515773ae714)\n\n#### 判断数据类型的其他方法\n    **Object.prototype.toString.call()**\n    可以实现转换形如：`[object RegExp]`，可以用来验证类型。\n        - 原理：https://www.cnblogs.com/ziyunfei/archive/2012/11/05/2754156.html\n\n### ❤️判断是否是数组：instanceof、Array.isArray、Object.prototype.toString.call([1,2,3])\nArray.isArray性能最好，instanceof次之，Object.prototype.toString.call性能最差\n\n### ❤️Array.prototype.reduce()的应用\n    格式化处理对象。比如源对象中将满足条件的所有字段，放入到一个reduce的第二个参数中。然后返回变更后的第二个参数。例子中第二个参数是个新对象，所以实际上是返回了一个新对象，该对象去掉了源对象中不满足条件的字段。\n        ```javascript\n        // 这段代码将会取出源对象中所有不为空串的字段，然后将这写字段添加到reduce的第二个参数（一开始是空对象），\n         Object.keys(search).reduce((result, key) => {\n                  let value = search[key];\n                  // 源对象中的树形如果不为空串，则将值加入到result中。result的初始值是空对象（reduce方法的第二个参数），随着每次迭代，result会不断改变。\n                  if (value !== \'\') {\n                    result[key] = value;\n                  }\n          \n                  return result;\n                }, {})\n        ```\n\n### ❤️函数表达式：函数表达式后必须跟匿名函数或者箭头函数，正常函数的函数名会被忽略。但是在函数内部可以正确访问函数名。\n    ```js\n    console.log(a); // undefined\n    //console.log(b); // 把注释去掉后会报错:b is not defined。因为函数名b被贿忽略了。\n    var a = function b() {\n        console.log(b) // 可以正确输出。猜测：可以用来在匿名函数内部对函数名进行操作比如下面的例子。\n    };\n    ```\n    \n    函数表达式编写递归调用函数\n        ```js\n        // 函数表达式的这种特性可以用来编写递归函数，\n        var factorial = (function f(num) {\n            if (num <= 1) {\n                return 1;\n            } else {\n                return num * f(num - 1);\n            }\n        });\n        \n        // 如果不用函数表达式，可能出现错误。\n        function factorial(num){\n            if (num <= 1){\n                return 1;\n            } else {\n                return num * factorial(num-1);\n            }\n        }\n        var anotherFactorial = factorial;\n        factorial = null;\n        alert(anotherFactorial(4)); //出错!因为内部调用了函数factorial，但是factorial已经是null了。\n        ```\n\n### ❤️箭头函数和普通函数区别\n    - 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。\n    - 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n    - 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用`(...arguments) => {}`参数代替。但是注意，普通函数的arguments是类数组。这种方法是数组。\n        ```js\n        let a = (...arguments) => {\n          console.log(arguments); // [1, 2, {abc:1}]\n        };\n        a(1,2,{abc:1});\n        ```\n    - 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n    - 箭头函数没有原型属性。\n    - 没有被提升（普通函数会有提升）（根本就没有函数名）\n\n### ❤️立即执行函数(function(){…})()\n    立即执行函数有多种写法，箭头函数支持持第一种\n```js\n(function(a){\n    console.log(a);   // 输出123,使用（）运算符\n})(123);// 换成箭头函数也支持\n\n(function(a){\n    console.log(a);   // 输出1234，使用（）运算符\n}(1234));// 不支持箭头函数\n\n!function(a){\n    console.log(a);   // 输出12345,使用！运算符\n}(12345);// 不支持箭头函数\n\n+function(a){\n    console.log(a);   // 输出123456,使用+运算符\n}(123456);// 不支持箭头函数\n\n-function(a){\n    console.log(a);   // 输出1234567,使用-运算符\n}(1234567);// 不支持箭头函数\n\nvar fn=function(a){\n    console.log(a);   // 输出12345678，使用=运算符\n}(12345678) // 不支持箭头函数\n```\n    立即执行函数和函数表达式一样，都会忽略函数的名称。\n```js\n!function b(a){\n    console.log(b,a);   // 输出函数b和数字12345\n}(12345);\nb(); // 报错 Uncaught ReferenceError: b is not defined。\n```\n    可以保证函数内的变量不被全局的变量污染（修改），并且，函数内还可以访问全局变量。俗称“匿名包裹器”或“命名空间”。\n    JQuery使用的就是这种方法，将JQuery代码包裹在( function (window,undefined){…jquery代码…} (window)中，在全局作用域中调用JQuery代码时，可以达到保护JQuery内部变量的作用。\n    参考：[深入理解javascript中的立即执行函数(function(){…})()](https://segmentfault.com/a/1190000008887645)\n\n### ❤️LHS和RHS\n    当变量出现在赋值操作的左侧时进行LHS查询（作用域链中寻找），出现在右侧时进行RHS查询（作用域链中寻找）。RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身\n    参考：[JS学习系列 01 - 编译原理和作用域](https://segmentfault.com/a/1190000007991284)\n\n### ❤️垃圾收集\n    局部变量只在函数执行的过程中存在。而在 这个过程中，会为局部变量在栈(或堆)内存上分配相应的空间，以便存储它们的值。然后在函数中使 用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供 将来使用。所以垃圾收集器必须跟踪哪个变量有用哪个变量没用。一般有以下两种策略：\n\n    **标记清除**\n    JavaScript 中`最常用的垃圾收集方式是标记清除(mark-and-sweep)`。当变量进入环境(例如，在函 数中声明一个变量)时，就将这个变量标记为“进入环境”。而当变量离开环境时，则将其 标记为“离开环境”。\n        - 可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境， 或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。\n        - 垃圾收集器会定期完成内存清除工作，不同浏览器的垃圾收集的时间间隔互有不同。\n\n    **引用计数**\n    引用计数的含义是跟踪记录每个值被引用的次数。\n    循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的 引用。所以它们的引用次数永远不会是 0，也就永远不会被清除。如果这两个对象定义在函数中，函数执行多次的话。就会导致大量内存得 不到回收。\n\n### ❤️console各种调试\n    - 所有属性，console.dir(obj)\n    - 调用堆栈，console.trace() // 运行到此处的调用堆栈。\n    - 计时，console.time(timerName),console.timeEnd(timerName),你可以启动一个计时器（timer）来跟踪某一个操作的占用时长。每一个计时器必须拥有唯一的名字，页面中最多能同时运行10,000个计时器。当以此计时器名字为参数调用 console.timeEnd() 时，浏览器将以毫秒为单位，输出对应计时器所经过的时间。\n        - console.timeLog(timerName)用来输出计时器的值。\n\n### ❤️eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。\n    将字符串当做代码运行，运行的执行上下文就是eval那一行。\n\n### ❤️ECMAScript中虽然没有规定函数参数的最大限制。但是不同浏览器会有限制（Chrome是65535个）。\n\n### ❤️Object的对象属性赋值。可以用空串、数字、null、undefined来作为键名。\n    ```js\n    let a = {}; // 或者var a = {}\n    a[\'\'] = 0;\n    a[\' \'] = 1;\n    a[null] = 2;\n    a[undefined] = 3;\n    // 或者var a = {\'\':0, \' \':1, null:2, undefined:3}\n    ```\n    使用数字+\'2\'作为键名的时，和使用字符串\'2\'作为键名时，将视为同一个键名，这里背后应该是做的相等判断而非全等判断：`+\'2\' == \'2\'`为true，`+\'2\' === \'2\'`为false\n    ```js\n    let a = {\n    	\'b\':\'c\',\n    	\'2\':\'b\',\n    	[+\'2\']:\'a\',\n    }; // 此时a中只有两个属性，b和2。数字2和字符串2都变成了字符串2。\n    console.log(+\'2\' === \'2\'); // 输出false。\n    console.log(a[+\'2\'],a[\'2\']); // \n```\n\n### ❤️Symbol作为对象的键名时是不枚举的。\n    意思就是如果一个对象中存在Symbol实例作为键名的字段的话，这个字段不会出现在`Object.keys`、`Object.values`、`Object.entries`、`for ... in循环`中。因为以上方法返回的只是可枚举的属性，而Symbol作为对象的键名时是不枚举的。\n    但是虽然说不可枚举，但是Object.getOwnPropertyDescriptor获取对象的Symbol实例的键名的对应的属性描述符时，描述符对应的`enumerable`字段居然是true。true是可枚举属性啊，表示可以出现在`Object.keys`和`for ... in循环`中。与实际表现不符。应该是个BUG就像typeof null 是object而不是null一样，属于遗留bug问题。\n```js\nlet a1 = Symbol(1);\nconsole.log(typeof a1);\nlet a = {\n	\'b\':\'c\',\n	[a1]:\'d\'\n};\nconsole.log(Object.keys(a),a[a1]);\nconsole.log(Object.getOwnPropertyDescriptor(a,\'b\'),Object.getOwnPropertyDescriptor(a,a1));\n```\n\n### ❤️利用Array构造函数创建数组时，可以传入数值类型的值来表示创建的数组的长度，也可以传入其他类型来指定数组中的项。\n```js\nvar colors = new Array(3); // 创建一个包含 3 项的数组，即，colors.length === 3\nvar names = new Array(\"Greg\"); // 创建一个包含 1 项，即字符串\"Greg\"的数组\nvar cities = Array(\"Beijing\", \"Shanghai\"); // 也可以不使用\'new\'关键字。\n```\n\n### ❤️数组的length可以改变，此属性不是只读属性。\n```js\n// 增加length\nvar colors = [\"red\", \"blue\", \"green\"]; // 创建一个包含 3 个字符串的数组 colors.length = 4;\nconsole.log(colors[3]); //undefined，此时length会实时的改变。\n  \n// 减小length\nvar colors = [\"red\", \"blue\", \"green\"]; // 创建一个包含 3 个字符串的数组 colors.length = 2;\nconsole.log(colors[2]); //undefined，此时length会实时的改变。\n```\n\n### ❤️Date\n\n#### 关于1970年1月1日 00:00:00\n    1970年，美国贝尔实验室的Ken Thompson。以BCPL语言为基础，设计出很简单且很接近硬件的B语言（取BCPL的首字母）。并且他用B语言写了第一个UNIX操作系统。\n    随后，汤普逊和同事丹尼斯里奇改进了B语言，开发出了C语言，重写了UNIX，新版于1971年发布。所以计算机起始时间是1970年1月1日。\n\n#### Date类型的表示范围\n    Date 类型保存的日期能够精确到 1970 年 1 月 1 日之前或之后的 100000000 天。js中Date类型的存储应该有一个固定长度的字节用来存储Date的毫秒数，所以会有个最大范围。\n\n#### Date作为构造函数\n    可接受数值类型或者字符串类型，数值表示从 UTC 时间 1970 年 1 月 1 日午 夜起至该日期止经过的毫秒数；如果是字符串，则尝试根据这个字符串返回相应日期的毫秒数。\n    参数是字符串时会调用Date.parse()。Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日 期的毫秒数。\n\n#### Date类型返回毫秒数（从1970年1月1日 00:00:00起）\n    valueOf()和getTime()。二者都返回数值。\n\n#### 参考 \n    [MDN-Date](Date对象：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date)\n\n### ❤️substring()、slice()和substr()的区别\n三者都会提取新串，而不会改变原串\n**substring**\n    第一个参数indexStart表示截取子串的开始，第二个参数indexEnd表示截取子串的结束位置（不包括该位置的字符）。\n    - 如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样（谁大谁就是结束位置）。\n    - 如果 indexStart 等于 indexEnd，substring 返回一个空字符串。\n    - 如果省略 indexEnd，substring 提取字符一直到字符串末尾。\n    - 如果任一参数小于 0 或为 NaN，则被当作 0（所以不能用负值来表示从字符串末尾开始计算的位置）。\n    - 如果任一参数大于 stringName.length，则被当作 stringName.length。\n\n**slice**\n    第一个参数beginIndex，从该索引（以 0 为基数）处开始提取原字符串中的字符。第二个参数endIndex可选，在该索引（以 0 为基数）处结束提取字符串（不包括该位置的字符）。\n    - 两个参数是负数时。会被当做 strLength + beginIndex 看待，这里的strLength 是字符串的长度（例如， 如果 beginIndex 是 -3 则看作是：strLength - 3）。\n    - 第二个参数如果省略，slice() 会一直提取到字符串末尾。\n\n**substr**\n    `该方法不建议使用`，mdn上表示它虽然没有被严格的废弃，但是会在将来移除。第一个参数start开始提取字符的位置。第二个参数length可选，提取的字符数。\n    - 第一个参数如果为负值，，则被看作 strLength + start，其中 strLength 为字符串的长度（例如，如果 start 为 -3，则被看作 strLength + (-3)）。\n    - 第一个参数start 如果为负值且 abs(start) 大于字符串的长度，则 substr 使用 0 作为开始提取的索引。\n    - 第一个参start 为正值，且大于或等于字符串的长度，则 substr 返回一个空字符串。\n    - 第二个参数length 为 0 或负值，则 substr 返回一个空字符串。\n\n### ❤️[正则-MDN-RegExp](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)\n\n### ❤️[废弃和过时的特性](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features)\n    这个页面可以查看哪些特性已经不建议使用。新标准中已经废除。\n### ❤️let的块级作用域的应用：for循环使用中使用let\n    for循环使用var和let时的区别及背后的含义，\n    **for使用var声明变量i，则i是全局作用域。所以i不会得到预期的结果**\n```html\n<body>\n    <ul>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n        <li>4</li>\n    </ul>\n    <script>\n        // 点击li并不会输出对应index，而会输出4。\n        var items = document.getElementsByTagName(\'li\');\n        var len = items.length;\n\n        for (var i = 0; i < len; i++) {\n            items[i].onclick = function () {\n                console.log(i);\n            }\n        }\n    </script>\n</body>\n```\n    点击li并不会输出对应index，而会输出4。因为for循环中的i是用var声明的，循环完了之后，i是4，并且循环完之后i也会存在。所以就输出了4。\n\n**for使用let声明变量i，则i是块级作用域，且，每次迭代，i都是一个固定的值。所以能得到预期的结果**\n```js\nfor (let i = 0; i < len; i++) {\n    items[i].onclick = function () {\n        console.log(i);\n    }\n}\nconsole.log(i);// 报错，Uncaught ReferenceError: i is not defined\n```\n### ❤️CDN 加速原理\n    - 负载均衡：通过使用CDN的DNS服务器进行负载均衡，将能够最快提供内容给用户的边缘节点返回给用户（就近原则）。\n    - 缓存机制：边缘节点的缓存服务器通过高效缓存（如内存）将本地缓存或者回溯上一级节点得到的内容返回给用户。\n    - 缓存数据同步保证缓存是最新数据。\n    - CDN预热：首次访问时CDN节点可能没有缓存，这时可以通过预热来使所有CDN节点有缓存，即从原站点主动发送缓存内容到各个边缘节点服务器。\n\n#### 参考\n    [CDN知识详解](https://zhuanlan.zhihu.com/p/28939811)\n    [简单的解释下什么是CNAME](https://blog.csdn.net/DD_orz/article/details/100034049)\n    [web网站加速之CDN技术原理](https://blog.csdn.net/5hongbing/article/details/78025349)\n\n### ❤️Object.defineProperty\n    可以对属性定义两种属性描述符，数据描述符和存取描述符,会直接改变对象\n    **存取描述符说的就是setter和setter，而getter和setter也可以在对象定义的时候定义**。\n#### setter:对象某个属性赋值时调用\n```js\nconst language = {\n  set current(name) {\n    this.log.push(name);\n  },\n  log: []\n}\n\nlanguage.current = \'EN\';\nconsole.log(language.log); // [\'EN\']\n\nlanguage.current = \'FA\';\nconsole.log(language.log); // [\'EN\', \'FA\']\n```\n    参考：[MDN-setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set)\n\n#### getter:对象某个属性获取时调用\n    参考：[MDN-getter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get)\n\n### ❤️展开运算符`...`\n\n#### 构造字面量对象时使用展开语法\n    ...展开对象赋值给另一个对象时，能达到浅拷贝，不会获取其prototype上的属性。浅拷贝(Shallow-cloning, 不包含 prototype) 和对象合并, 可以使用更简短的展开语法。而不必再使用 Object.assign() 方式\n    Object.assign() 函数会触发 setters，而展开语法则不会。\n    参考:[展开语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax)\n\n### ❤️MouseEvent 鼠标事件\n\n#### mouseover和mouseenter\n    **mouseover的触发元素可以是元素本身，也可以是其子元素。**\n        - 鼠标进入元素A本身，但没有进入其子元素。上述条件发生时，元素A本身会触发mouseover，event.target是元素A本身。\n        - 鼠标进入元素A的子元素B。注意即使鼠标超出了元素A的范围，但是子元素B的定位是在元素A的范围外（`position:absolute`）。上述条件发生时，子元素B会触发mouseover事件，event.target是子元素B。\n        - 综上所述，向一个元素添加事件监听（addEventListener）时，元素本身，和其子元素都会触发这个事件监听，可以通过event.target判断是本身还是其子元素。\n        - 参考[MDN-mouseover event](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseover_event)\n\n    **mouseenter的触发元素只能是元素本身。**\n        - 参考[MDN-mouseover event](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event)\n\n    **mouseover和mouseenter同时触发时，会先触发mouseover，再出发mouseenter**\n\n#### mouseout和mouseleave\n    **mouseout的触发元素可以是元素本身，也可以是其子元素。**\n        - 鼠标进入元素A本身，但没有进入其子元素，然后离开元素本身，或者进入元素A的子元素（子元素挡住了元素A的可见区域，所以进入其子元素视为离开元素A）。上述条件发生时，元素A本身会触发mouseout，event.target是元素A本身。\n        - 鼠标进入元素A的子元素B，然后离开子元素B，注意可能直接离开了子元素的父元素A，或者进入其他的子元素C，都视为离开子元素B。上述条件发生时，子元素B会触发mouseout事件，event.target是子元素B。\n        - 综上所述，向一个元素添加事件监听（addEventListener）时，元素本身，和其子元素都会触发这个事件监听，可以通过event.target判断是本身还是其子元素。\n        - 参考[MDN-mouseover event](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseout_event)\n\n    **mouseleave的触发元素只能是元素本身。**\n        - 参考[MDN-mouseover event](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event)\n\n    **mouseleave和mouseout同时触发时，会先触发mouseout，再出发mouseleave**\n\n#### MouseEvent.relatedTarget：鼠标事件的次要目标（如果存在）。如果事件没有次要目标，relatedTarget 将返回 null。\n\n|事件名称|target|relatedTarget|\n| -----:| ----: | ----:|\n|focusin | EventTarget 获取焦点 | EventTarget 失去焦点 |\n|focusout|EventTarget 失去焦点|The EventTarget 获取焦点|\n|mouseenter|指针设备进入 EventTarget|指针设备离开EventTarget|\n|mouseleave|指针设备离开 EventTarget|指针设备进入EventTarget|\n|mouseout|指针设备离开 EventTarget|The EventTarget|\n|mouseover|指针设备进入 EventTarget|指针设备离开 EventTarget|\n|dragenter|指针设备进入 EventTarget|指针设备离开 EventTarget|\n|dragexit|指针设备离开 EventTarget|指针设备进入 EventTarget|\n\n    [参考MDN-MouseEvent.relatedTarget](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/relatedTarget)\n\n### ❤️点击两次鼠标左键，mousedown，mouseup，click，dblclick的触发顺序。\n    + mousedown\n    + mouseup\n    + click\n    + mousedown\n    + mouseup\n    + click\n    + dblclick\n\n### ❤️keydown、keypress、keyup、input、chang触发时机和顺序\n    `input type=\'text\'`按下字符或数字（有字符输入）触发顺序：keydown、keypress、input、keyup。\n    **radio或者checkbox点击时先触发input后触发change**\n    **change触发**\n    - 当元素被:checked时（通过点击或者使用键盘）：<input type=\"radio\"> 和 <input type=\"checkbox\">；\n    - 当用户完成提交动作时（例如：点击了 <select>中的一个选项，从 <input type=\"date\">标签选择了一个日期，通过<input type=\"file\">标签上传了一个文件，等)；\n    - 当标签的值被修改并且失焦后，但并未进行提交（例如：对<textarea> 或者<input type=\"text\">的值进行编辑后。）。\n    - [参考MDN-change](https://developer.mozilla.org/zh-CN/docs/Web/Events/change)\n\n    **input**\n    - 当一个 <input>, <select>, 或 <textarea> 元素的 value 被修改时，会触发 input 事件。\n    - 当用户完成提交动作时（例如：点击了 <select>中的一个选项，从 <input type=\"date\">标签选择了一个日期，通过<input type=\"file\">标签上传了一个文件，等)；\n    - 注意兼容性：当元素被:checked时（通过点击或者使用键盘）：<input type=\"radio\"> 和 <input type=\"checkbox\">；\n    - [参考MDN-input](https://developer.mozilla.org/zh-CN/docs/Web/Events/input)\n\n    **keydown**\n    - keydown触发时，文本并没有改变。\n    - 非英文输入法，keycode是229（229可能和浏览器有关，待深究），可用来监听正在输入。\n    - 当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件\n\n    **keyup**\n    - keyup触发时，文本已经改变。\n    - 当用户释放键盘上的键时触发。\n\n    **keypress：不建议使用，未来会废弃。**\n    - 输入入了有效字符，并且\n    - https://developer.mozilla.org/en-US/docs/Web/API/Document/keypress_event\n    - 当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下`Esc`键也会触发这个事件。\n    \n    [**在线测试验证网站**](https://www.w3.org/2002/09/tests/keys.html)`\n\n### ❤️JSON.stringify:可接受三个参数！！第一个参数是json不用说。\n    - 第二个参数replacer：如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化；\n    - 第三个参数space：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串（当字符串长度超过10个字母，取其前10个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。\n    - undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如JSON.stringify(function(){}) or JSON.stringify(undefined)。\n    - 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。(就是说第一个参数如果是个数组，序列化后的字符串是有顺序的。数组中的每个元素顺序排列)。\n    - 转换值（第一个参数）如果有 toJSON() 方法，该方法定义什么值将被序列化。如果第一个参数有toJSON方法并且传了第二个参数，执行顺序如下：\n        - 如果存在 toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。\n        - 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是上一步返回的值。\n    - [参考-MDN-JSON.stringify()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n\n### ❤️JSON.parse():可接受两个参数！！第一个参数是json字符串不用说。\n    - 第二个参数转换器reviver： 如果传入该参数(函数)，可以用来修改解析生成的原始值，调用时机在 parse 函数返回之前。\n    - [参考-MDN-JSON.parse()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)\n\n### ❤️密封对象和冻结对象\n\n#### 密封对象，Object.seal()\n    不可增加属性、删除属性。原来属性的配置（配置是指Object.defineProperty的那种配置）不会改变。一般情况下可修改密封对象的原有属性的值。\n    [参考-MDN-Object.seal()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)\n\n#### 冻结对象，Object.freeze()\n    冻结的对象既不可扩展，又是密封的，而且对象 数据属性的\\[\\[Writable]]特性会被设置为 false。如果定义\\[\\[Set]]函数，访问器属性仍然是可写的。\n    - [参考-MDN-Object.freeze()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n\n#### 区别\n    密封的对象只是不能增加、删除新属性，其他所有的操作，和普通的对象没区别。\n    冻结对象除了不能增加、删除新属性以外，还不能修改已有属性的值和已有属性的描述符的配置（配置是指Object.defineProperty的那种配置）。\n\n### ❤️scrollIntoView：可以在所有 HTML 元素上调用，通过滚动浏览器窗口或某个容器元素，调用 元素就可以出现在视口中。\n    - 如果给这个方法传入 true 作为参数，或者不传入任何参数，那么窗口滚动 之后会让调用元素的顶部与视口顶部尽可能平齐。\n    - 如果传入 false 作为参数，调用元素会尽可能全部 出现在视口中，(可能的话，调用元素的底部会与视口底部平齐。)不过顶部不一定平齐。\n    - 替他方法：为某些元素设置焦点也会导致浏览器滚动并显示出获得焦点的元素，比如input、textarea、select等。', '2017-08-13 16:20:42', '2021-12-02 15:01:32');
INSERT INTO `article` VALUES (6, 1, 'VUE 知识点', 1, '❤️$refs是undefined缩进$refs定位不到的主要原因是因为v-if、v-for、v-show这些语', '### ❤️`$refs`是undefined\n    `$refs`定位不到的主要原因是因为`v-if`、`v-for`、`v-show`这些语句如果依赖父组件传来的参数的话，该该参数是在mounted()阶段子还没获取得到~~~~！！！！如果想要真正地在DOM加载完成后拿到数据，就需要调用VUE的全局api ： `this.$nextTick(() => {})`', '2017-08-31 12:30:00', '2017-08-31 12:30:00');
INSERT INTO `article` VALUES (7, 1, 'JavaScript和Native交互', 1, 'js调用native有这些方法方法一 ：改变window对象。缩进native在webview的window对象', '### js调用native有这些方法\n\n#### 方法一 ：改变window对象。\n    native在webview的window对象上注册方法，js直接调用。实现js调native。只能单向、js调端。\n#### 方法二：拦截URL SCHEME。\n    js通过http协议或者自定义的类似的URL协议来告诉native我要调用的方法名、参数、回调函数等信息。native拦截到这个URL并解析后，执行。\n      URL类似：`weixin://JSBridge:1538351/method?{\"message\":\"msg\"}`或\n                     `http://weixin.web2native.com?method?message=msg`\n  + js可以通过调用window.prompt或window.alert或window.confirm方法，来将这种URL告诉native。native可以拦截到。\n  + js还可以通过IFrame的src变化，来将这种URL及参数告诉native。native也可以拦截到。\n  + js还可以通过location.href的变化，来将这种URL及参数告诉native。native也可以拦截到，但是这种方法如果连续多次修改location.href的值，在native层只能接收到最后一次请求。\n  + js还可以通过发送http请求的方式，来将这种URL及参数告诉native。native也可以拦截到，', '2017-09-03 20:11:10', '2021-11-01 14:24:19');
INSERT INTO `article` VALUES (8, 1, 'JavaScript 变量提升', 1, '  变量提升缩进变量提升:变量会经历：定义（注册）、初始化、使用（赋值', '###   变量提升\n    变量提升:变量会经历：定义（注册）、初始化、使用（赋值或者使用）、销毁。这些过程。js中访问没有被初始化的变量会报错。一般讲的var会发生变量提升，说的是定义和初始化的过程会被提升。所以你在`var a = 1`之前打印`a`会输出undefined。ES6的let会有所不同。他只提升了定义过程，但是并没有提升初始化的过程。\n\n#### 全局变量：\n    - var 声明全局变量，这个全局变量会作为 window 对象的一个属性\n    - let 声明的全局变量不会成为 window 的属性。\n    - 不使用关键字声明的变量和直接`window.xx`的变量是一样的。\n    - var 声明的变量和不使用关键字声明的变量都会成为window上的一个属性，但是通过Object.getOwnPropertyDescriptor获取属性描述符发现属性描述符中的configurable不一致。\n        - 使用 var 声明的全局变量的configurable数据属性的值为 false\n        - 不使用关键字声明的变量的configurable数据属性的值为 true\n        - 因为当且仅当configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。所以，var声明的全局变量无法用delete 从window上删除，而不使用关键字声明的变量却可以被删除。\n\n#### 声明函数和变量（ES5/ES6）\n    - 声明变量有四种方式：不使用关键字，使用var，使用let，使用const。\n    - 声明函数有四种方式：直接定义，函数表达式，箭头函数，箭头函数表达式。\n\n#### 变量提升的不同情况\n    以上8种方式，由于函数表达式和箭头函数表达式的实质就是声明变量，所以和声明变量的方式是一样的；由于箭头函数不存在标识符（名称），所以不存在变量提升；所以只有5中情况需要考虑是否存在变量提升，分别是：\n\n    **1 不使用关键字声明变量：不存在任何提升。**\n    这种方式相当于直接在window上定义变量。只有执行过那一行代码之后，才可以正常使用。\n            ```js\n            console.log(window.hasOwnProperty(\'a\')); // false,注意，直接console.log(a)会报错。\n            a = 1;\n            console.log(a);// 1\n            ```\n\n    **2 var声明变量：定义过程提升，初始化过程（初始化undefined）也被提升。所以一般认为var提升了。**\n            ```js\n            console.log(a); // undefined,注意，window.hasOwnProperty(\'a\')为true，对比不使用关键字生命的变量。\n            var a = 1;\n            console.log(a);// 1\n            ```\n\n    **3 let声明变量：定义过程提升了，但是初始化过程没有被提升，存在于暂存死区里，所以直接访问会报错：ReferenceError，Cannot access \'a\' before initialization。**\n    不要抬杠，这个错和没有定义变量直接访问的错不一样，虽然都是ReferenceError，但是那个错是: xxx is not defined。\n            ```js\n            console.log(a); // 报错ReferenceError，Cannot access \'a\' before initialization。对比未定义的错误：xxx is not defined。所以说并不是未定义。\n            let a = 1;\n            console.log(a);// 因为报错未输出\n            ```\n> 注意: 直接在浏览器的控制台中执行代码不会的到Cannot access \'a\' before initialization的错误，而是a is not defined。需要编写好html用浏览器打开页面才会报Cannot access \'a\' before initialization。\n\n    **4 const声明变量：同let**\n\n    **5 直接定义函数：定义过程和初始化过程均被提升了。**这里的初始化并没有初始化为undefined，而是初始化为函数体。所以函数可以在定义前使用。\n\n### 变量提升优先级\n\n    - 同名情况时（`let a = 1`和`function a(){}`同时出现），会报错重复定义，两个语句谁在前，谁在后，都会报重复定义的错误。两个语句的提升失败(猜测是在提升过程中发现了定义冲突)。\n    - 同名情况时（`var a = 1`和`function a(){}`同时出现），var的提升会被function的提升覆盖。\n            ```js\n            console.log(a); // 输出a是一个函数，而不是undefined。\n            var a = 1;\n            function a() {}\n            console.log(a); // 输出1。\n            ```\n    - 函数内形参和var变量同名，则var的提升被忽略。函数内形参和函数内的函数生命同名，则函数内的函数的提升会覆盖形参(不论参数是函数还是变量)。\n\n#### 参考\n[MDN-let](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let)', '2017-09-10 16:01:22', '2021-12-02 16:46:44');
INSERT INTO `article` VALUES (9, 1, 'JavaScript 执行环境、作用域链、函数执行过程、闭包和this', 1, '执行环境及作用域链缩进执行环境定义了变量或函数有权访问的其他数据，', '### 执行环境及作用域链\n    执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个 与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。\n    在 Web 浏览器中，全局执行环境被认为是 window 对象，因 此所有全局变量和函数都是作为 window 对象的属性和方法创建的。\n    如果这个执行环境是环境是函数，则将其活动对象(activation object)作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象(这个对象在全局环境中是不存在的)。\n\n    执行环境栈：每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。    \n    作用域链：当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。\n    函数定义时就会预先创建一个除函数本身以外的作用域链，包括但不一定出现：父函数（如果有）、父函数的父函数（如果有）、全局执行环境的作用域（window）。并存在于自己的`[[Scopes]]`属性中，可以通过console.dir(func)查看函数的作用域链。此时的作用域链形成有如下规则。\n        + 假设函数a，直系祖辈函数集合B，有祖辈函数b属于B。\n        + 祖辈函数b中的本地变量只要在b的任意后代中有使用（这个后代函数可以是a，也可以是其他后代函数，甚至a的后代函数），这样的所有被使用的变量所组成的变量对象，才会作用域中形成一个节点。\n        + 简单的讲，就是a的直系函数（直系祖辈和直系祖辈的后代函数形成的所有函数）中用到的变量才会出现在作用域链中。没用到的那些，在变量所归属的函数执行完毕之后肯定会被销毁。应该是为了最大程度的降低闭包所占用的变量对象的对应内存。\n\n    标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止(如果找不到标识符，通常会导致错误发生)。\n    如果标识符在当前作用域（变量对象）中找不到。则会向父级作用域找。\n    全局执行环境的变量对象始终都是作用域链中的最后一个对象。\n    延长作用域链：有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移 除。在两种情况下会发生这种现象。\n         + try-catch 语句的 catch 块;\n         + with 语句。\n         + 对 with 语句来说，会将指定的对象添加到作用域链中。对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。\n\n    使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部 环境;在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自 动被添加到全局环境。\n\n### 函数执行过程\n    遇到函数执行是总的来说会进行两大步：\n    **创建执行环境（执行上下文），然后。压入调用栈**\n    然后这一步比较复杂，分为以下小步：\n        - 创建一个空的活动对象（变量对象），将函数参数argument类数组放入其中。（箭头函数没有argument数组，则放入参数）\n        - 变量提升、函数提升，提升后放入活动对象：先提升函数，如果函数名和形参一致。则直接覆盖函数名。然后提升变量，变量名和形参或者函数名一致。则忽略。即执行函数内的函数会覆盖一切，执行函数的参数次之，执行函数内的变量优先级最低。\n        - 将函数定义时就预先贮备的作用域链（介绍作用域链时说过）复制到执行环境中，然后将刚刚准备好的活动对象。加入到作用域链的前面。\n\n    **执行函数体，若遇到函数执行，则重复这两大步**。变量的解析、赋值就从作用域链中一级一级寻找。\n        - 执行函数的时候会确定this的指向。\n\n    每个函数在被调用时都会自动取得两个特殊变量:this 和 arguments。内部函 数在搜索这两个变量时，只会搜索到其活动对象为止。\n        ```js\n        var name = \"The Window\";\n        var object = {\n            name : \"My Object\",\n            getNameFunc : function(){\n                return function(){\n                    return this.name;\n                };\n        } };\n        alert(object.getNameFunc()());//\"The Window\"而不是\"My Object\"\n        ```\n\n    查看调用堆栈：可以写一个闭包的小例子，然后在浏览器（chrome中）的开发者工具界面查看函数的执行栈（调用堆栈）和每一个栈对应的作用域链。执行栈叫Call Stack，作用域链叫Scope。可以点击Call Stack中的一项，然后Scope则会显示对应的作用域链。\n\n### 闭包：可以访问函数内部变量的函数\n    本质上就是作用域链的创建。将函数定义A在其他函数B内部，则该函数A的作用域链就包含函数B活动对象（因为只有在B执行的时候，才会创建函数A，所以包含B的活动对象）。当函数A执行的时候，作用域链时A的活动对象->B的活动对象—>上一层作用域。这样，函数A自然可以访问函数B的内部变量，即使，函数B执行后已经销毁了。\n    因为会保存其他函数的变量对象，所以过度使用闭包会导致内存泄漏。\n    闭包只能取得包含函数中任何变量的最 后一个值。\n        ```js\n        function createFunctions(){\n        	var result = new Array();\n        	for (var i=0; i < 10; i++){\n  	     	    // 实际上，每个函数都返回 10。而不是对应的下标，因为当createFunctions执行完成后，i是10。\n        		result[i] = function(){\n        			return i; \n  		        };\n        	}\n        	return result;\n        }\n        // 将上面的var i 换成let i则会返回不同的值。或者将i作为函数参数传递\n        // 修改后在包裹一层匿名函数。然后将下标作为参数传入\n        function createFunctions() {\n        	var result = new Array();\n        	for (var i = 0; i < 10; i++) {\n        		result[i] = function (num) {\n        			return function () {\n        				return num;\n        			}\n        		}(i)\n        	}\n  	     	return result;\n        }\n        ```\n    闭包的this一般指向window。\n\n### this \n    this一定是在执行时决定的，指向调用函数的对象。在闭包、回调函数、赋值等场景下我们都可以利用 call / apply / bind 来改变 this 的指向，以达到我们的预期。\n    在全局环境中直接调用函数，函数中的 this 会在调用时被 JS 引擎设置为全局对象 window。无论这个函数是全局函数还是函数中的定义的函数。\n\n    函数可以作为对象的方法被该对象调用，那么这种情况 this 会被设置为该对象\n\n    call(), apply(), bind()可以改变this指向。\n\n    函数返回函数会形成闭包。在这种情况下，闭包往往所执行的环境与所定义的环境不一致，而 this 的值却是在执行时决定的。\n        ```js\n        var name = \'Neil\';\n        \n        var person = {\n          name: \'Leo\',\n          sayHi: function() {\n            return function () {\n              return \'Hi! My name is \' + this.name;\n            }\n          }\n        };\n        \n        person.sayHi()(); // \"Hi! My name is Neil\"。注意事项Neil不是Leo\n        ```\n    当上面代码中的闭包在执行时，它所在的执行上下文是全局环境，this 将被设置为 window\n\n    当把函数赋值给其他对象，用其他对象调用时，this指针将发生改变。\n        ```js\n        var name = \'Neil\';\n        \n        var person = {\n          name: \'Leo\',\n          sayHi: function() {\n            return \'Hi! My name is \' + this.name;\n          }\n        };\n        \n        person.sayHi(); // \"Hi! My name is Leo\"\n        \n        var foo = person.sayHi;\n        \n        foo(); // \"Hi! My name is Neil\"\n        ```\n    当把 person.sayHi() 赋值给一个变量，这个时候 this 的指向又发生了变化。因为 foo 执行时是在全局环境中，所以 this 指向 window\n\n### 参考\n《JavaScript高级程序设计》第三版4.2章节', '2017-09-14 17:10:11', '2021-12-02 17:27:27');
INSERT INTO `article` VALUES (10, 1, 'JavaScript call()/apply()/bind()中的应用与实现', 1, 'JavaScript call()/apply()/bind()中的应用与实现。call()的应用缩进可以通过call实现', '### JavaScript call()/apply()/bind()中的应用与实现。\n\n### call()的应用\n    可以通过call实现继承、调用匿名函数、改变this指针\n```javascript\n  function Product(name, price) {\n    this.name = name;\n    this.price = price;\n  }\n  \n  function Food(name, price) {\n    Product.call(this, name, price);\n    this.category = \'food\';\n  }\n  \n  function Toy(name, price) {\n    Product.call(this, name, price);\n    this.category = \'toy\';\n  }\n  \n  var cheese = new Food(\'feta\', 5);\n  var fun = new Toy(\'robot\', 40);\n``` \n\n### apply()的应用\n    实现继承、数组合并、允许类（伪）数组使用数组方法、使内置方法的不定个数参数数组化。\n```javascript\n  // 数组合并\n  var array = [\'a\', \'b\'];\n  var elements = [0, 1, 2];\n  array.push.apply(array, elements);\n  console.info(array); // [\"a\", \"b\", 0, 1, 2]\n\n  // 允许类（伪）数组使用数组方法，类数组本身只能遍历，不能使用数组方法\n  var domNodes = Array.prototype.slice.apply(document.getElementsByTagName(\"*\")); // call也可以\n\n  // 使内置方法的不定个数参数数组化\n  /* 找出数组中最大/小的数字 */\n  var numbers = [5, 6, 2, 3, 7];\n  \n  /* 应用(apply) Math.min/Math.max 内置函数完成 */\n  var max = Math.max.apply(null, numbers); /* 基本等同于 Math.max(numbers[0], ...) 或 Math.max(5, 6, ..) */\n  var min = Math.min.apply(null, numbers);\n```\n\n### bind()的应用\n    实现继承、创建绑定函数（改变this）、偏函数（有预设的参数）、配合 setTimeout、onclick这些会改变函数this的情况。\n    如果连续 bind() 两次，亦或者是连续 bind() 只有第一次的bind会生效。\n\n    **偏函数**\n```javascript\n    function list() {\n      return Array.prototype.slice.call(arguments);\n    }\n    \n    function addArguments(arg1, arg2) {\n        return arg1 + arg2\n    }\n    \n    var list1 = list(1, 2, 3); // [1, 2, 3]\n    \n    var result1 = addArguments(1, 2); // 3\n    \n    // 创建一个函数，它拥有预设参数列表。\n    var leadingThirtysevenList = list.bind(null, 37);\n    \n    // 创建一个函数，它拥有预设的第一个参数\n    var addThirtySeven = addArguments.bind(null, 37); \n    \n    var list2 = leadingThirtysevenList(); \n    // [37]\n```\n\n    **配合 setTimeout**\n    在默认情况下，使用 window.setTimeout() 时，this 关键字会指向 window （或 global）对象。当类的方法中需要 this 指向类的实例时，你可能需要显式地把 this 绑定到回调函数，就不会丢失该实例的引用。\n```javascript\n    function LateBloomer() {\n      this.petalCount = Math.ceil(Math.random() * 12) + 1;\n    }\n    \n    // 在 1 秒钟后声明 bloom\n    LateBloomer.prototype.bloom = function() {\n      window.setTimeout(this.declare.bind(this), 1000);\n    };\n    \n    LateBloomer.prototype.declare = function() {\n      console.log(\'I am a beautiful flower with \' +\n        this.petalCount + \' petals!\');\n    };\n    \n    var flower = new LateBloomer();\n    flower.bloom();  // 一秒钟后, 调用 \'declare\' 方法\n```\n\n### 实现\n**call()的实现**\n```javascript\nFunction.prototype.leeCall = function() {\n    var context = arguments[0] || window;\n    var result;\n    context.fn = this;\n    if (arguments.length === 1) {\n        result = context.fn();\n    } else {\n        var fn = \'context.fn(\';\n        var args = [];\n        for (var i = 1; i < arguments.length; i++) {\n            args.push(\'arguments[\'+i+\']\');\n        }\n        fn = \'context.fn(\'+args+\")\";\n        result = eval(fn);\n    }\n    delete context.fn;\n    return result;\n};\n```\n\n**apply()的实现**\n```javascript\nFunction.prototype.leeApply = function() {\n    var context = arguments[0] || window;\n    var result;\n    context.fn = this;\n    if (!arguments[1]) {\n        result = context.fn();\n    } else {\n        var fn = \'context.fn(\';\n        var args = [];\n        for (var i = 0; i < arguments[1].length; i++) {\n            args.push(\'arguments[1][\'+i+\']\');\n        }\n        fn = \'context.fn(\'+args+\")\";\n        result = eval(fn);\n    }\n    delete context.fn;\n    return result;\n};\n```\n\n**bind()的实现**\n```javascript\nFunction.prototype.leeBind = function() {\n    var context = arguments[0] || window;\n    var args = [];\n    var target = this;\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n    }\n    var boundFunction = function () {\n        if (arguments.length >= 1) {\n            for (var i = 0; i < arguments.length; i++) {\n                args.push(arguments[i]);\n            }\n        }\n        // 如果是new 关键字调用函数的话，就需要忽略bind时传入的第一个值（this对象）\n        return target.leeApply(this instanceof boundFunction ?this:context,args)\n    };\n\n    if (target.prototype) {\n        boundFunction.prototype = Object.create(target.prototype);\n        boundFunction.prototype.constructor = target.prototype.constructor;\n    }\n\n\n    return boundFunction;\n};\n```', '2017-09-16 09:55:10', '2017-09-16 09:55:10');
INSERT INTO `article` VALUES (11, 1, 'JavaScript new的原理和实现', 1, 'JavaScript new的原理和实现缩进普通函数作为构造函数时，使用new和不使用new', '### JavaScript new的原理和实现\n    普通函数作为构造函数时，使用new和不使用new的区别：不使用new的话，构造函数里的this指向的就是window。\n\n#### 原理\n    new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作：\n    **1 创建一个空的简单JavaScript对象（即{}）**\n```javascript\n    var obj = {}\n```\n\n    **2 链接该对象（将构造函数的 prototype 赋值给新对象的 __proto__）**\n```javascript\n    obj.__proto__= Func.prototype;\n```\n\n    **3 将步骤1新创建的对象作为this的上下文 ；**\n```javascript\n    var result = Func.apply(obj, args); \n```\n\n    **4 如果该函数没有返回对象，则返回this。**\n```javascript\n    if(typeof result === \'object\'){\n        return result\n    }else{\n        return obj;\n    }\n```\n\n#### 实现new\n```javascript\n    var New =function(fn){\n        var obj={};\n        obj.__proto__=fn.prototype;\n        // 将 arguments 对象转为数组\n        var args = [].slice.call(arguments,1);\n        // 执行构造函数并改变this对象\n        var result = fn.apply(obj, args);            \n        if(Object.prototype.toString.call(result)==\"[object Object]\" ){\n            return result\n        }else{\n            return obj;\n        }\n    }\n```', '2017-09-22 00:00:00', '2017-09-22 00:00:00');
INSERT INTO `article` VALUES (12, 1, 'forEach和async/await[前端面试题系列]', 1, '面试题缩进输出以下代码运行结果，为什么？1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nc', '### 面试题\n    输出以下代码运行结果，为什么？\n```js\nconst list = [1, 2, 3]\nconst square = num => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(num * num)\n    }, 1000)\n  })\n}\n\nfunction test() {\n  list.forEach(async x=> {\n    const res = await square(x)\n    console.log(res)\n  })\n}\ntest()\n```\n\n    输出：1秒之后，输出1、4、9。forEach不能被阻塞，所以test执行时，顺序执行三个new Promise，而不会等待第一个new Promise的resolve完成，这就是所谓的forEach不能被阻塞。所以当test函数执行完成之后，定时器线程中有三个计时的setTimeout，且时间都是1秒，1秒后，执行三个new Promise的resolve，也就是说，test函数执行完成之后，1秒后，三个new promise的resolve顺序执行，即执行await的res赋值和console.log(res)执行，然后输出了1、4、9。从结果上来看，就是代码执行完成之后，控制台输出了1、4、9。\n\n    如果希望每隔 1s 输出一个结果，应该如何改造？注意不可改动 square 方法。\n首先，可以做如下修改:用for循环替代forEach\n```js\nconst list = [1, 2, 3]\nconst square = num => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(num * num)\n    }, 1000)\n  })\n}\nasync function test() {\n  for (let i = 0; i < list.length; i++) {\n    let x = list[i]\n    const res = await square(x)\n    console.log(res)\n  }\n}\ntest()\n```\n\n### 数组的forEach方法的是不可中断的、不可阻塞的，尤其使用async/await的时候，代码的执行结果可能会产生意想不到的结果。\n    除了抛出异常以外，没有办法中止或跳出 forEach() 循环。如果你需要中止或跳出循环，forEach() 方法不是应当使用的工具。\n    下面代码会输出什么。\n```js\nlet ratings = [5, 4, 5];\n\nlet sum = 0;\n\nlet sumFunction = async function (a, b) {\n    return a + b;\n} \n\nratings.forEach(async function(rating) {\n    sum = await sumFunction(sum, rating);\n})\n\nconsole.log(sum);\n```\n    上面的代码会输出0，而不会输出14。想想因为啥，async/await将函数的变成了promise的执行，然后相当于promise.then里执行的sum赋值和累加操作，但是这三次累加操作需要等这一轮时间循环执行完成之后才能执行，因为代码还没执行完，forEach后面还有console.log，所以将他们放到微任务队列中。这时将要执行console.log，而此时，sum仍然是0，因为，赋值和累加操作还在为任务队列中没有被执行。\n\n### 参考\n[MDN-Array.prototype.forEach()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n[Daily-Interview-Question-160](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/389)', '2017-11-13 16:10:03', '2017-11-13 16:10:03');
INSERT INTO `article` VALUES (13, 1, '实现Promise.retry[前端面试题系列]', 1, '面试题缩进实现 Promise.retry，成功后 resolve 结果，失败后重试，尝试超过一', '### 面试题\n    实现 Promise.retry，成功后 resolve 结果，失败后重试，尝试超过一定次数才真正的 reject。\n    比如有如下请求fetchData\n```js\nfunction fetchData() {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      resolve(\'response\')\n    }, 1000);\n  });\n};\r\n```\n\n    实现的retry函数调用方式如下：\n```js\nretry(fetchData, 3)\n```\n\n### 题解\n```js\nPromise.retry = function (promiseFunc, num = 2) {\n  return promiseFunc().then(null, (e) => {\n    if (num > 0) {\n      num -= 1;\n      console.log(\"重试\");\n      return Promise.retry(promiseFunc, num);\n    }\n    return Promise.reject(e);\n  });\n};\n```', '2017-11-15 10:14:00', '2017-11-15 10:14:00');
INSERT INTO `article` VALUES (14, 1, 'JavaScript的BigInt', 1, 'BigInt的含义缩进BigInt是一种新的基本数据类型。缩进BigInt是一种内置对象，', '### BigInt的含义\n    BigInt是一种新的基本数据类型。\n    BigInt是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是 Javascript中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数。可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数BigInt()。\n```js\n// 字面量表示\nconst theBiggestInt = 9007199254740991n;\n\n// 调用函数表示\nconst alsoHuge = BigInt(9007199254740991);\n```\n\n### BigInt的要点\n+ typeof 测试时， BigInt 对象返回 \"bigint\" ，也就是说，BigInt是基本数据类型。\n+ 不能用于 Math 对象中的方法。\n+ 不能和任何 Number 实例混合运算,两者必须转换成同一种类型。\n+ 操作符可以和 BigInt 一起使用：`+`、`*`、`-`、`**`、`%` 。除 `>>> （无符号右移）`之外的 位操作 也可以支持。\n+ 当使用 BigInt 时，带小数的运算会被取整。\n+ BigInt 和 Number 不是全等的，但是相等的。\n+ Number 和 BigInt 可以进行比较，提示，可以比较则表示两者也可以混在一个数组内并排序（array.sort()方法）。\n+ BigInt 在需要转换成 Boolean 的时表现跟 Number 类似，如：可以在if语句中使用。\n\n    下面我们举例对要点进行说明\n    **BigInt是基本数据类型**\n```js\n    typeof 1n === \'bigint\'; // true\n    typeof BigInt(\'1\') === \'bigint\'; // true\n```\n\n    **BigInt不能用于Math对象中的方法**\n![***BigInt如果用于Math对象中的方法则会报错***](//blogserver.jiaxuanlee.com/static/article-file/14/381095500.png)\n\n    **BigInt不能和任何 Number 实例混合运算,两者必须转换成同一种类型**\n![***BigInt不能和任何 Number 实例混合运算，否则会报错***](//blogserver.jiaxuanlee.com/static/article-file/14/BigInt和Number混合运算.png)\n\n    **BigInt的运算**\n    `+`、`*`、`-`、`**`、`%` 。除 `>>> （无符号右移）`之外的 位操作 也可以支持。但是注意：BigInt 不支持单目 (+) 运算符。单目(-)视为取负值。\n```js\nconst previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER);\n// 9007199254740991n\n\nconst maxPlusOne = previousMaxSafe + 1n;\n// 加运算：9007199254740992n\n\nconst multi = previousMaxSafe * 2n;\n// 乘运算：18014398509481982n\n\nconst subtr = multi – 10n;\n// 减运算：18014398509481972n\n\nconst mod = multi % 10n;\n// 取模运算：2n\n\nconst bigN = 2n ** 54n;\n// 幂运算：18014398509481984n\n\nbigN * -1n\n// 负运算 –18014398509481984n\n\nbigN * +1n\n// 单目+运算  报错：Uncaught TypeError: Cannot convert a BigInt value to a number\n```\n\n    **当使用 BigInt 时，带小数的运算会被取整**\n```js\nconst expected = 4n / 2n;\n// 2n\n\nconst rounded1= 5n / 2n;\n// 2n, not 2.5n，向下取整，相当于Math.floor\n```\n\n    **BigInt 和 Number 不是全等的，但是相等的**\n```js\n0n === 0\n// false\n\n0n == 0\n// true\n```\n\n    **Number 和 BigInt 可以进行比较**\n```js\n1n < 2\n//  true\n\n2n > 1\n// true\n\n2 > 2\n// false\n\n2n > 2\n// false\n\n2n >= 2\n// true\n\n// Number和BigInt混合的排序\nconst mixed = [4n, 6, -12n, 10, 4, 0, 0n];\n// [4n, 6, -12n, 10, 4, 0, 0n]\n\nmixed.sort();\n// [-12n, 0, 0n, 10, 4n, 4, 6]\n```\n\n    **BigInt用于逻辑运算**\n```js\nif (0n) {\n  console.log(\'Hello from the if!\');\n} else {\n  console.log(\'Hello from the else!\');\n}\n\n//  \"Hello from the else!\"\n\n0n || 12n\n// 12n\n\n0n && 12n\n// 0n\n\nBoolean(0n)\n// false\n\nBoolean(12n)\n// true\n\n!12n\n// false\n\n!0n\n// true\n```\n\n### BigInt的方法\n[BigInt.asIntN()(点击查看详细用法)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asIntN)\n    将 BigInt 值转换为一个 -2width-1 与 2width-1-1 之间的有符号整数。\n\n[BigInt.asUintN(点击查看详细用法)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN)\n    将一个 BigInt 值转换为 0 与 2width-1 之间的无符号整数。\n\n[BigInt.prototype.toLocaleString()(点击查看详细用法)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/toLocaleString)\n    返回此数字的 language-sensitive 形式的字符串。覆盖 Object.prototype.toLocaleString()  方法。\n\n[BigInt.prototype.toString()(点击查看详细用法)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/toString)\n    返回以指定基数(base)表示指定数字的字符串。覆盖 Object.prototype.toString() 方法。\n\n[BigInt.prototype.valueOf()(点击查看详细用法)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/valueOf)\n    返回指定对象的基元值。 覆盖 Object.prototype.valueOf() 方法。\n```js\nvar a = 1n\nundefined\na.toLocaleString()\n\"1\"\na.toString()\n\"1\"\na.valueOf()\n1n\n```\n\n### 在 JSON 中使用\n    对任何 BigInt 值使用 JSON.stringify() 都会引发 TypeError，因为默认情况下 BigInt 值不会在 JSON 中序列化。但是，如果需要，可以实现 toJSON 方法：\n```js\nBigInt.prototype.toJSON = function() { return this.toString(); }\n```\nJSON.stringify 现在生成如下字符串，而不是抛出异常:\n```js\nJSON.stringify(BigInt(1));\n// \'\"1\"\'\n```\n### 参考\n[MDN-BigInt](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt)', '2017-10-14 09:23:00', '2021-11-01 14:22:12');
INSERT INTO `article` VALUES (15, 1, 'JavaScript的Symbol', 1, '关于Symbol缩进JS中Symbol的使用可以分为两类，一类用法是把Symbol当做方法来', '### 关于Symbol\n    JS中Symbol的使用可以分为两类，一类用法是把Symbol当做方法来调用，生成自定义的Symbol来使用。另一类用法是通过把Symbol当成内置对象，调用Symbol对象的属性或方法来进行使用。举两个简单的例子来说明一下两种用法。\n\n    **调用Symbol()方法来生成自定义的Symbol**。\n```js\nSymbol(\"foo\") !== Symbol(\"foo\")\nconst foo = Symbol()\nconst bar = Symbol()\ntypeof foo === \"symbol\"\ntypeof bar === \"symbol\"\nlet obj = {}\nobj[foo] = \"foo\"\nobj[bar] = \"bar\"\nJSON.stringify(obj) // {}\nObject.keys(obj) // []\nObject.getOwnPropertyNames(obj) // []\nObject.getOwnPropertySymbols(obj) // [ foo, bar ]\n```\n    创建自定义的Symbol就是使用Symbol()方法，上面的例子已经说明。这里说一下要点：\n+ 每个从Symbol()返回的symbol值都是唯一的。\n+ 一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。（但不代表你只能这么用它）。\n+ 使用Symbol() 函数的语法，不会在你的整个代码库中创建一个可用的全局symbol类型。\n+ Symbol类型的数据可以通过description(Symbol.prototype.description)这个属性来获取其键值。与Symbol.prototype.toString() 不同的是它不会包含 \"Symbol()\" 的字符串。\n+ Symbol 不会被隐式转换为字符串，比如和字符串拼接。\n+ Symbol()返回的值去定义对象的属性，这个属性是匿名的。并且是不可枚举的。\n    因为这个属性是不可枚举的，它不会在循环结构 “for( ... in ...)” 中作为成员出现，也因为这个属性是匿名的，它同样不会出现在 “Object.getOwnPropertyNames()” 的返回数组里。Object.keys、Object.values、Object.entries等方法也无法获取Symbol()返回的值定义对象的属性。\n\n    **Symbol对象的属性或方法来修改某些对象的某些默认行为**\n    比如有一个普通的字面量object，我们要遍历这个对象的键或值一般通过`for...in`循环和`Object.hasOwnProperty`，或者通过`for...of`和`Object.entries`等一些方法。`for...of`是无法直接对普通的object对象使用的。然而`for...of`的循环其实是利用对象的迭代器，来实现的。而普通的对象不包含这种迭代器，但是我们可以通过Symbol.iterator来定义对象的`for...of`循环的迭代器。也就是说，Symbol.iterator表示的是系统的一个特殊键名，这个键名可以用来获取或设置对象的for...of`循环的迭代器。\n```js\nlet obj = {a:\'aa\',b:\'bb\'};\nobj[Symbol.iterator] = function*() {\n	yield [\'a\',this[\'a\']]\n	yield [\'b\',this[\'b\']]\n}\nfor (let [k,v] of obj) {\n        // 如果不定义Symbol.iterator，则无法直接对obj进行for...of循环。这里只是举个例子，上面定义的Symbol.iterator具体内容也许不合理，但是形式是对的。\n	console.log(k,v);\n}\n```\n除了可以定义对象迭代器的Symbol.iterator，Symbol还有很多属性，这些属性都是表示的某些对象的某些默认行为的键名，通过这些键名，就可以修改对应对象的对应默认行为。\n\n### Symbol()的创建自定义Symbol\n    分别说明一下Symbol的要点。\n    **每个从Symbol()返回的symbol值都是唯一的**\n    Symbol()可以传入一个参数，这个参数是生成的Symbol的描述符，没传的话，也可以生成Symbol，但是描述符是undefined。Symbol()保证是每次调用的结果唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。\n```js\nSymbol(\"foo\") !== Symbol(\"foo\"); // true，表示两次生成的Symbol不同。 \n```\n    **一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的**\n\n    **使用Symbol() 函数的语法，不会在你的整个代码库中创建一个可用的全局symbol类型**\n\n    **Symbol.prototype.description获取symbol的描述符**\n```js\nlet id = Symbol(\"id\");\nconsole.log(id.description); // id。与Symbol.prototype.toString() 不同的是它不会包含 \"Symbol()\" 的字符串\nconsole.log(id.toString()); // Symbol(id)\n```\n\n    **Symbol 不会被隐式转换为字符串，比如和字符串拼接**\n```js\nlet a = Symbol(\'a\');\nconsole.log(a.toString() + \'1\');\nconsole.log(a + \'1\');//因为不会自动去隐式转换字符串，所以会报错，Uncaught TypeError: Cannot convert a Symbol value to a string。\n```\n\n    **Symbol()返回的值去定义对象的属性，这个属性是匿名的。并且是不可枚举的**\n    因为这个属性是不可枚举的，它不会在循环结构 “for( ... in ...)” 中作为成员出现，也因为这个属性是匿名的，它同样不会出现在 “Object.getOwnPropertyNames()” 的返回数组里。Object.keys、Object.values、Object.entries等方法也无法获取Symbol()返回的值定义对象的属性。\n```js\nSymbol(\"foo\") !== Symbol(\"foo\")\nconst foo = Symbol()\nconst bar = Symbol()\ntypeof foo === \"symbol\"\ntypeof bar === \"symbol\"\nlet obj = {}\nobj[foo] = \"foo\"\nobj[bar] = \"bar\"\nJSON.stringify(obj) // {}，注意没有foo和bar\nObject.keys(obj) // []，注意没有foo和bar\nObject.getOwnPropertyNames(obj) // []，注意没有foo和bar\nObject.getOwnPropertySymbols(obj) // [ foo, bar ]，注意没有foo和bar\n```\n\n    **全局Symbol**\n[Symbol.for(key)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for)\n    使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。\n\n[Symbol.keyFor(sym)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/keyFor)\n    从全局symbol注册表中，为给定的symbol检索一个共享的?symbol key。\n\n### Symbol对象的属性或方法来修改某些对象的某些默认行为\n    就是有一些系统的Symbol，即JavaScript内建了一些在ECMAScript 5 之前没有暴露给开发者的symbol，它们代表了内部语言行为。它们可以使用以下属性访问：\n\n**迭代 symbols**\n[Symbol.iterator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator)\n    一个返回一个对象默认迭代器的方法。被 [for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of) 使用。\n\n[Symbol.asyncIterator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator)\n    一个返回对象默认的异步迭代器的方法。被 [for await of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of) 使用。\n\n**正则表达式 symbols**\n[Symbol.match](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/match)\n    一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。被[String.prototype.match()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match)使用。\n\n[Symbol.replace](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/replace)\n    一个替换匹配字符串的子串的方法. 被[String.prototype.replace()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace)使用。\n[Symbol.search](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/search)\n    一个返回一个字符串中与正则表达式相匹配的索引的方法。被[String.prototype.search()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search)使用。\n\n[Symbol.split](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/split)\n    一个在匹配正则表达式的索引处拆分一个字符串的方法.。被[String.prototype.split()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split)使用。\n\n**其他 symbols**\n[Symbol.hasInstance](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance)\n    一个确定一个构造器对象识别的对象是否为它的实例的方法。被[instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)使用。\n\n[Symbol.isConcatSpreadable](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable)\n    一个布尔值，表明一个对象是否应该flattened为它的数组元素。被[Array.prototype.concat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)使用。\n\n[Symbol.unscopables](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/unscopables)\n    拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。\n\n[Symbol.species](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species)\n    一个用于创建派生对象的构造器函数。\n\n[Symbol.toPrimitive](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)\n    一个将对象转化为基本数据类型的方法。\n\n[Symbol.toStringTag](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag)\n    用于对象的默认描述的字符串值。被[Object.prototype.toString()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString)使用。', '2017-10-14 13:13:00', '2017-10-14 13:13:00');
INSERT INTO `article` VALUES (18, 1, '从浏览器看HTTP缓存', 1, 'HTTP缓存缩进官方文档：Caching in HTTP缩进HTTP缓存是HTTP中规范中规定的，不同', '## HTTP缓存\n    官方文档：[Caching in HTTP](https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html)\n    HTTP缓存是HTTP中规范中规定的，不同浏览器的实现可能会有细微的差别。\n\n### 1 为什么缓存\n    通过复用以前获取的资源，可以显著提高网站和应用程序的性能。\n+ Web 缓存减少了下载资源的时间和网络流量，因此减少了显示资源表示形式所需的时间。\n+ 浏览器前进后退等时候可以快速的显示页面。\n\n### 2 哪些资源可以被缓存\n    主要是网站的静态资源，如：js、css、img等。\n    [mdn的HTTP缓存文档](https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ) 有比较官方的解释，一下内容可能会被缓存：\n+ 一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应。\n+ 永久重定向: 响应状态码：301。\n+ 错误响应: 响应状态码：404 的一个页面。\n+ 不完全的响应: 响应状态码 206，只返回局部的信息。\n\n### 3 缓存到哪里\n    缓存到哪是浏览器决定的。但是观察过chrome的Network面板我们发现有的是`from memory cache`有的是`from disk cache`。看的出来就是内存和硬盘，内存读取肯定要快，但是空间小；硬盘读取慢，但是空间大。\n    memory cache：一般脚本、字体、图片会存在内存当中。\n    disk cache：一般非脚本会存在内存当中，如css等。\n    具体不细究。涉及到浏览器底层的设计和一些考虑。这也不是我们关注的重点。\n\n### 4 初步了解浏览器的缓存\n#### 命中缓存的前提\n    请求必须是和缓存的那次请求使用相同的请求URL。比如以下虽然都能表示`abc.js`，但是却是不同的url，不会命中缓存。\n    - http://xxx.com/abc.js?v=001\n    - http://xxx.com/abc.js?v=002\n    - http://xxx.com/abc.a5f2b2.js\n    - http://xxx.com/abc.342dae.js\n\n    注意不是说不会被缓存，而是说相互之间不会命中对方的缓存，因为URL变了是对不同资源的请求。比如先后两次请求http://xxx.com/abc.js?v=001时，假设第一次的响应被缓存了，第二次会使用第一次的缓存；\n    但是当先请求http://xxx.com/abc.js?v=001，然后响应被缓存了，在请求http://xxx.com/abc.js?v=002时，就不会使用缓存，即使请求的目标文件是一样的，但是请求的URL不一样对于http来说是不同的资源。\n\n    然后简单的说一下过程：\n- 浏览器第一次请求时，会根据服务器返回的响应头的信息来告诉浏览器，要不要缓存这次请求的结果。\n- 浏览器第二次请求时，如果缓存处于有效期并且缓存策略允许直接使用缓存，则直接使用缓存；如果缓存处于有效期但是需要验证缓存是否可用，则去验证，服务器要么告诉你可以使用，要么会给你最新的结果。\n\n    以上只是简单说明一下过程，心里有个大概的流程。\n\n### 5 强制缓存和协商缓存（对比缓存）\n#### 强制缓存\n    前面提到，浏览器第一次请求时，会根据服务器返回的响应头的信息来告诉浏览器，要不要缓存这次请求的结果。缓存的不仅仅是内容，一些相关的响应头信息都会被缓存下来。那么浏览器就有了本地缓存，那么浏览器再次对这个资源，或者URL请求时，就会先从缓存里找，找到之后浏览器会根据存下的响应头的信息来决定缓存是否过期，没过期就直接使用缓存，过期了就向服务器请求。这里的 header 中的信息指的是`[Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)` 和 `[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)` 。\n\n#### 协商缓存\n    当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。这里的 header 中的信息指的是`Last-Modified`，`If-Modified-Since`和 `ETag`，`If-None-Match`。\n\n### 6 强缓存 `[Pragma](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma)`、`[Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)` 、`[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)`\n\n    `[Pragma](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma)` 是一个在 HTTP/1.0 中规定的通用header，作为响应头或请求头都可以，这个header的效果依赖于不同的实现，所以在“请求-响应”链中可能会有不同的效果。已经不建议使用，只在需要兼容 HTTP/1.0 客户端的场合下使用。这个header只有一个值就是`no-cache`。\n\n    `[Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)` 是一个在 HTTP/1.0 中规定的响应头，表示日期/时间， 即在此时候之后，响应过期，即缓存也过期了。如果在`Cache-Control`响应头设置了 `max-age` 或者 `s-max-age` 值，那么 `Expires` 头会被忽略。\n\n    `[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)` 是一个在 HTTP/1.1 中规定的通用header，被用于在http请求和响应中，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。\n\n    介绍了三个header的含义，我们来分别看看每个header的具体的值。由于 `[Pragma](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma)` 不建议使用，我们只介绍`[Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)` 、`[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)` 。\n\n    `[Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)` 的值就表示一个绝对时间的GMT格式的字符串，比如 `Expires: Wed, 21 Oct 2015 07:28:00 GMT`。在这个时间点之前，缓存是有效的，没过期，可以直接使用。时间点之后，就要向服务器获取新的资源。这样做有一个缺点，就是这个时间是服务器给你的时间，当服务器的时间和客户端的时间相差较大时，就会导致缓存的有效期不准确，就可能会导致页面呈现不正确。所以HTTP/1.1就规定了新的`[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)` 。\n\n    `[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)` 的值有很多种，但我们首先要注意的是，这是一个通用header，可以是请求头，也可以是响应头。并且是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。这里我们只介绍一些常见的值。\n    + `public` 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有max-age指令或Expires消息头；2. 该响应对应的请求方法是 POST 。）\n    + `private` 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。\n    + `no-cache` 在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。\n    + `no-store` 缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。\n    + `max-age=xxx`设置缓存存储的最大周期，单位秒，超过这个时间缓存被认为过期。与`Expires`相反，时间是相对于请求时间的间隔。\n\n    `[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)` 的值其实有三大类：可缓存性、到期、其他。\n    可缓存性的值表示的都是这次服务器的响应缓存策略，比如是否能被缓存；到期的值表示的都是缓存的有效期，也就是我们说的强制缓存的有效期。其他的值不常用。\n    除此之外，我们需要注意，有的值只能在作为请求头时使用，有的只能在作为响应头时使用，有的则都能。我们上面介绍的5中值则都能。\n\n    **缓存请求指令，作为请求头时**\n    客户端可以在HTTP请求中使用的标准 Cache-Control 指令。\n> Cache-Control: max-age=<seconds>\n> Cache-Control: max-stale[=<seconds>]\n> Cache-Control: min-fresh=<seconds>\n> Cache-control: no-cache \n> Cache-control: no-store\n> Cache-control: no-transform\n> Cache-control: only-if-cached\n\n\n    **缓存响应指令，作为响应头时**\n    服务器可以在响应中使用的标准 Cache-Control 指令。\n> Cache-control: must-revalidate\n> Cache-control: no-cache\n> Cache-control: no-store\n> Cache-control: no-transform\n> Cache-control: public\n> Cache-control: private\n> Cache-control: proxy-revalidate\n> Cache-Control: max-age=<seconds>\n> Cache-control: s-maxage=<seconds>\n\n\n    下面我们举例说明一下如何使用`[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)`\n    **禁止缓存**\n    发送如下响应头可以关闭缓存。此外，可以参考Expires和Pragma消息头。\n> Cache-Control: no-store\n\n\n\n    **缓存静态资源**\n    对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，CSS文件和JavaScript文件。另请参阅Expires标题。\n> Cache-Control:public, max-age=31536000\n\n\n\n    **需要重新验证**\n    指定 no-cache 或 max-age=0 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。\n> Cache-Control: no-cache\n> Cache-Control: max-age=0\n\n\n\n#### 注意的问题\n+ `cache-control`和`Expires`\n    - 通常说`cache-control`比`Expires`优先级高，正确的说法是如果在`Cache-Control`响应头设置了 `max-age` 或者 `s-max-age` 值，那么 `Expires` 头会被忽略。\n        - 也就是说，如果是`Cache-Control:private`和`Expires:Wed, 21 Oct 2015 07:28:00 GMT`这样的响应，那么`Expires`的值还是有效的，即缓存的有效期就是`Expires`的值。\n        - 而如果是`Cache-Control:max-age=300`和`Expires:Wed, 21 Oct 2015 07:28:00 GMT`这样的响应，那么`Expires`就无效了，`max-age`的值生效。即缓存的有效期就是请求后的300s。\n+ `cache-control`的`max-age=0`和`no-cache`。\n    - 感觉是一样的，使用起来也都是协商缓存。在stackoverflow上也没找到特别有实际意义的答案，说的都是`max-age=0`和`no-cache`理解上有区别，但是实际是检验之后，浏览器的处理是一样的，都相当于协商缓存。\n    - `max-age=0,must-revalidate`和`no-cache`都表示协商缓存，即缓存是否可用需要向服务器验证。\n    - `must-revalidate`和`no-cache`不一样，`must-revalidate`表示强制缓存`max-age=xxx`失效之前，缓存可以直接使用，失效后需要验证。而`no-cache`表示无论如何，缓存都需要向服务器验证。\n\n#### 强缓存总结如下：\n    那么介绍完了三个头，我们说的强制缓存与服务器的响应头中`[Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)` 和 `[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)` 有关就明白是为什么了。\n    强缓存就是`Expires:Wed, 21 Oct 2015 07:28:00 GMT`或者在`Cache-Control`响应头设置了 `max-age`  值。二者同时出现的场景我们也说了。其实你会发现，如果`Cache-Control`响应头设置了 `max-age`和`no-cache`怎么办呢？是的，`Cache-Control`的值可以是组合值。组合值的一些情况我们最后再说，包括不设置`[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)`的情况。\n\n### 7 协商缓存`[Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified)`，`[If-Modified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since)` 和 `[ETag](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag)`，`[If-None-Match](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match)`\n\n    `[Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified)`，`[If-Modified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since)` 是一对，`Last-Modified`是响应头，`If-Modified-Since`是请求头。\n\n    `[Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified)` 是一个响应头，其中包含服务器认定的资源做出修改的日期及时间。 它的值被用来在下次请求该资源时作为请求头，向服务器做协商缓存的新鲜度验证。\n\n    `[If-Modified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since)` 是一个请求头，需要配合`Last-Modified`使用，`If-Modified-Since` 的值是浏览器缓存资源时服务器返回的响应头中的 `Last-Modified`的值。只可以用在 GET 或 HEAD 请求中。\n    二者都是GMT时间的字符串，精确到秒。\n\n    浏览器第一次请求一个资源的时候，如果服务器响应头中会加上 `Last-Modified` ，表示该资源的最后修改时间。当浏览器再次请求该资源时，请求头中会包含`If-Modified-Since` ，该值为缓存之前返回的`Last-Modified`。服务器收到`If-Modified-Since`后，\n    如果在这个日期时间之后对内容进行过修改的情况下才会将更新后的资源返回，状态码为200。\n    如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的304响应，表示命中缓存，浏览器使用缓存。并且不会返回资源内容，不会返回`Last-Modified`。但是如果返回了强制缓存的响应头，比如`Cache-Control:max-age=300`,那么这个会更新到浏览器缓存中，下次再请求会走强缓存策略，而不是一直304。\n    缺点:由于精确度是秒，所以当服务器在一秒内修改了该资源时，`Last-Modified`无法验证这种情况，因为最后修改时间没变。所以便出现了Etag。\n    `Last-Modified`除了请求头`If-Modified-Since`可以配合使用之外还有一个含义类似的`[If-Unmodified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since)` 。\n    表示只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源，或是接受 POST 或其他 non-safe 方法的请求。如果所请求的资源在指定的时间之后发生了修改，那么会返回 412 (Precondition Failed) 错误。 \n\n    `[ETag](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag)` 和 `[If-None-Match](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match)` 也是一对，`ETag`是响应头，`If-Modified-Since`是请求头。\n\n    `[ETag](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag)` 是一个响应头，是服务器根据资源的特定版本的内容生成的标识符，这个资源只要内容没变，则一定要生成新的Etag值。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web服务器不需要发送完整的响应。\n\n    `[If-None-Match](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match)` 是一个请求头，配合 `ETag` 使用，`If-None-Match` 的值是浏览器缓存资源时服务器返回的响应头中的 `ETag`的值。\n    浏览器第一次请求一个资源的时候，如果服务器响应头中会加上 `ETag` ，表示该资源的最后的版本。当浏览器再次请求该资源时，请求头中会包含`If-None-Match` ，该值为缓存之前返回的`Last-ETag`。服务器收到`If-None-Match`后，\n    如果在这个版本之后对内容进行过修改的情况下才会将更新后的资源返回，状态码为200。\n    如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的304响应，表示命中缓存，浏览器使用缓存。\n\n    ETag机制同时支持强校验和弱校验。它们通过ETag标识符的开头是否存在“W/”来区分，如：\n> \"123456789\"   -- 一个强ETag验证符\n> W/\"123456789\"  -- 一个弱ETag验证符\n    \'W/\'(大小写敏感) 表示使用弱验证器。 弱验证器很容易生成，但不利于比较。 强验证器是比较的理想选择，但很难有效地生成。 相同资源的两个弱Etag值可能语义等同，但不是每个字节都相同。\n    强Etag能唯一地表示所请求的资源，一个字节不同，则Etag的值就不同。因此，弱的`Etag`，资源改变时，并不一定表示`Etag`值会变。\n\n\n    那么Etag是如何计算的呢\n    关于 Etag 的生成需要满足几个条件，至少是宽松满足:\n+ 当文件更改时，Etag 值必须改变。\n+ 尽量便于计算，不会特别耗 CPU。因为不能为了计算一个资源的Etag值就花费很多时间。\n+ 分布式部署时多个服务器节点上生成的 Etag 值保持一致。\n\n    那么可以使用的比如：MD5, SHA128, SHA256。\n\n    下面举几个例子：\n+ 比如利用SHA1的[纯前端文件名生成算法(七牛ETag算法)示例](https://developer.aliyun.com/article/658190)\n+ 比如express的Etag是用的[jshttp/Etag](https://github.com/jshttp/Etag) 库，而[jshttp/Etag](https://github.com/jshttp/Etag) 也是利用sha1。参考[响应头中的 ETag 值是如何生成的](https://www.cnblogs.com/everlose/p/12779653.html)\n+ Nginx计算Etag的是弱Etag，算法是`Last-Modified` + `Content-Length` 翻墙后参考[Algorithm behind nginx Etag generation](https://serverfault.com/questions/690341/algorithm-behind-nginx-Etag-generation)\n+ 还有比如针对大文件计算Etag是分一个个小部分计算md5然后在组合的方式，翻墙后参考[What is the algorithm to compute the Amazon-S3 Etag for a file larger than 5GB?](https://stackoverflow.com/questions/12186993/what-is-the-algorithm-to-compute-the-amazon-s3-Etag-for-a-file-larger-than-5gb)\n\n### 8 浏览器的操作对强缓存和协商缓存的影响\n    前进/后退，地址栏回车，页面链接跳转：强缓存生效、协商缓存生效\n    正常刷新（刷新按钮点击或者F5或者CMD+R）：强缓存无效、协商缓存生效\n    强制刷新（Ctrl+F5或者Shift+CMD+R）：强缓存无效、协商缓存无效\n    chrome 54之后，改变了正常刷新的行为，编程正常刷新和地址栏回车和loaction.reload都是只对页面本身地址对应的文件本身（一般是index.html）是强缓存不生效、协商生效（添加cache-control: max-age=0），页面中那些引用的资源（js、css、图片等都是）强缓存和协商缓存都生效。\n    简单的说就是54之后正常刷新变成和地址栏回车类似的行为了。只是页面地址对应的html的处理不一样。\n    Chorme从版本54开始，为什么做出改变是因为firefox提出的`Cahche-control`的`Immutable`值。参考[你可能不需要协商缓存](https://www.thjiang.com/2019/08/17/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/) ）的最后部分\n\n### 9 总结\n    浏览器缓存整体流程如下：\n![浏览器缓存整体流程](//blogserver.jiaxuanlee.com/static/article-file/18/http缓存.png)\n    发出请求后，会先在本地查找缓存。\n    没有缓存去服务端请求最新的资源，返回给客户端（200），并重新进行缓存。\n    查到有缓存，要判断缓存本地是否过期(max-age等)。\n    没有过期，直接返回给客户端（200 from cache）。\n    如果缓存过期了，看是否有配置协商缓存（Etag/Last-Modified），去服务端再验证该资源是否更新，本地缓存是否可以继续使用。\n    如果发现资源可用，返回304，告知客户端可以继续使用缓存，并根据max-age等更新缓存时间。不需要返回数据，加速请求时间。\n    如果服务端再验证失败，请求最新的资源，返回给客户端（200），并重新进行缓存。\n    如果在协商缓存时浏览器请求服务器时设置了`Etag`对应的请求头和`Last-Modified`对应的请求头，比如`If-None-Match`和`If-Modified-Since`。那么服务器要验证资源是否同时满足这两个请求头的值时，才会返给你304。\n\n    我们常说的强缓存，其实就是直接在本地缓存获取，也就是Cache-Control: max-age等配置，不需要和服务端沟通。\n而协商缓存是在强缓存的基础上，配置Etag或Last-Modified等参数。本地缓存失效后，去服务端进行新鲜度检测。可以避免每次本地缓存过期后都返回最新的数据，造成请求缓慢。\n\n### 10 注意的问题\n+ `Etag`和`Last-Modified`谁优先级高\n    - 简单的理解：已知Etag > Last-Modified，即Etag优先级更高，因为Etag是根据文件内容计算的，而Last-Modified是根据秒，如果1秒内资源改变了，Last-Modified没变，但是Etag会改变，从而能让用户看到最新的页面。\n    - 本质上，当与 If-None-Match 一同出现时，它（If-Modified-Since）会被忽略掉，除非服务器不支持 If-None-Match来自 [mdn的解释](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since) 。\n+ cache的组合值的优先级\n    - no-cache和max-age\n        - 同时存在时，no-cache生效，即第一次之后的后续请求都是协商缓存。\n    - no-store和max-age\n        - no-store生效，即第一次之后的后续请求都是从服务器下载，既不是强缓存也不是协商缓存。\n    - no-store和no-cache\n        - no-store生效，即第一次之后的后续请求都是从服务器下载，既不是强缓存也不是协商缓存。\n    - 总结no-store、no-cache、max-age三者的优先级优先级。\n        - no-store > no-cache > max-age\n+ 没有设置`Cache-Control`或者`Expires`\n    - 没有`Cache-Control`但是有`Expires`\n        - 通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。\n    - 强制缓存条件不成立的时候（强制缓存成立取反，强制缓存成立是说`Cache-Control`为`max-age`，或者有`Expires`）\n        - 一般情况下都会有`Last-Modified`，如果有`Last-Modified`，不管有没有`Etag`。缓存的时间就等于相应头里面`Date`（服务器的时间）的值减去`Last-Modified`的值除以10（注：根据rfc2626其实也就是乘以10%），相当于设置了`max-age`。\n        - 如果没有`Last-Modified`也没有`Etag`，那么就不缓存，这种情况下其实是`Cache-Control`、`Expires`、`Etag`、`Last-Modified`都没有。就不缓存。\n        - 如果只有`ETag`，没有`Last-Modified`、`Cache-Control`、`Expires`，则是协商缓存。\n\n### 11 如何使用http缓存\n    分几种途径，一种是通过添加请求头和响应头；一种是资源文件名是hash加强缓存的方式；一种是通过HTML的meta标签的http-equiv=\"cache-control\"的方式。\n通过添加响应头是根据不同服务器有不同的操作。\n    比如Nginx服务器：\n    以下代码片段可以添加到 Nginx 配置文件中。这个例子里面使用了 Cache-Control 响应头的 public指令和no-transform指令，同时设置了过期时间（expire）为两天。\n> 如果在 Cache-Control 中增加max-age设置，则在最终的响应头里面会出现两个 max-age 的值。因此，对于 Nginx 的配置来说，使用expires就可以了。\n\n\nlocation ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\n    expires 2d;\n    add_header Cache-Control \"public, no-transform\";\n}\n\n\n\n    另一种通过HTML的meta标签的http-equiv=\"cache-control\"的方式，没有太多的资料，似乎只有一种用法，并且兼容性很差，所以不建议使用。但还是把代码放出来看一下：\n```html\n<meta http-equiv=\"cache-control\" content=\"no-cache\" /> \n```\n\n    资源文件名是hash加强缓存的方式是说。引入js文件或者css文件或图片文件的时候，通过webpack的contenthash或者hash来表示资源的版本。然后在响应头中设置如`cache-control: max-age=604800`这样的强缓存。时间可以是一年，半年，可根据网站的更新周期来决定。\n```html\n<script type=\"text/javascript\" src=\"app.a5f2b2.js\"></script>\n```\n    因为html浏览器一般指协商缓存或者不缓存，在网站新版本发布时，引用路径就变成了新版本的路径，这样做能保证，请求资源时浏览器中的强缓存肯定不会命中，因为资源的url路径变了，因为资源的URL不一样。所以相当于请求新的资源，所以强缓存无效。\n    新资源请求后，由于我们使用了强缓存，所以，会在本地保留一年，半年等时间。再次请求时使用强缓存。\n    这样即能保证在发布新版本后，用户不用强制刷新，使用普通方式打开网站就能浏览到最新版，即所谓的浏览器能得知服务器更新；又能保证用户能快速看到页面，即使用了浏览器缓存。\n\n### 12 参考\n    [轻松理解浏览器缓存(Koa缓存源码解析)](https://juejin.cn/post/6844904133024022536#heading-24)\n    [http 响应头中的 ETag 值是如何生成的](https://q.shanyue.tech/base/http/112.html#nginx-%E4%B8%AD-etag-%E7%9A%84%E7%94%9F%E6%88%90)\n    [理解浏览器缓存](https://www.cnblogs.com/lijianming180/p/12376064.html)\n    [浏览器缓存机制、浏览器默认缓存行为](https://www.cnblogs.com/little-baby/p/12721685.html)\n    [HTTP 缓存](https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)\n    [彻底理解浏览器的缓存机制（http缓存机制）](https://www.cnblogs.com/chengxs/p/10396066.html)\n    [实践这一次，彻底搞懂浏览器缓存机制](https://segmentfault.com/a/1190000017962411)\n    [图文讲解 Cache-Control 浅显易懂](https://zhuanlan.zhihu.com/p/79042406)\n    [网站的缓存控制策略最佳实践及注意事项](https://shanyue.tech/frontend-engineering/http-cache.html)\n    [浅谈http中的Cache-Control](https://blog.csdn.net/u012375924/article/details/82806617)\n    [Caching in HTTP](https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html)\n    [Caching Tutorial](https://www.mnot.net/cache_docs/)\n    [MDN-Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)\n    [What happens if you don\'t set cache-control header?](https://webmasters.stackexchange.com/questions/111298/what-happens-if-you-dont-set-cache-control-header)\n    [What\'s default value of cache-control?](https://stackoverflow.com/questions/14496694/whats-default-value-of-cache-control)\n    [Difference between no-cache and must-revalidate](https://stackoverflow.com/questions/18148884/difference-between-no-cache-and-must-revalidate)\n    [What\'s the difference between Cache-Control: max-age=0 and no-cache?](https://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache)\n    [浏览器缓存机制](https://www.zhoulujun.cn/html/theory/ComputerScienceTechnology/network/2018_0306_8078.html)\n    [你可能不需要协商缓存](https://www.thjiang.com/2019/08/17/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/)', '2018-04-05 10:02:30', '2021-11-01 14:20:30');
INSERT INTO `article` VALUES (19, 1, 'css中的font-family', 1, 'font-family我们指定网站字体时通常会在有如下代码1\n2\n3\nhtml{\n    font-family: \"PingF', '## font-family\n我们指定网站字体时通常会在有如下代码\n```css\nhtml{\n    font-family: \"PingFang SC\",Arial,\"Microsoft YaHei\",sans-serif;\n}\n```\n`font-family`后面跟的几个值，每个值都代表什么字体呢，浏览器又是按照什么规则来显示网站中的字的呢？\nfont-family后面跟两种值，字体族（一种字体）和通用字体族。\n\n### 字体族（单字体）\n首先字体族，表示一种特定的字体，比如：`PingFang SC`苹果产品（iPhone、iPad、Mac等）自带的字体平方，`Microsoft YaHei`微软字体雅黑。\n字体族名可以包含空格，但包含空格时应该用引号，就像上面的`PingFang SC`在css中写就是`font-family: \"PingFang SC\"`，加引号；\n如果字体族名不包含空格，可以不用加引号，比如：`font-family: Arial`。\n所以在书写时字体族直接一律加上引号。\n字体族表示的字体又分为两大类：系统带的，和自定义的。系统带的就是设备系统自带的字体或者安装过的字体。\n自定义的字体是在CSS中用`@font-face`定义的字体，那定义字体就要有字体文件，字体文件可以是在服务器本地或者是用第三方的字体文件的URL（一般是http或https的地址）。比如下面的例子：\n```css\n@font-face {\n	font-family: \'leeIcon\';\n	src: url(\'./fonts/leeIcon.ttf\');\n    /*使用URL的的那种\n    src: url(https://fonts.gstatic.font.im/s/robotocondensed/v18/ieVl2ZhZI2eCN5jzbjEETS9weq8-19-7DQk6YvNkeg.woff2)*/\n	font-weight: normal;\n	font-style: normal;\n	font-display: block;\n}\n```\n上面的代码你可以自己定义在自己的css文件中，即上面这样；或者是第三方帮你写好css，然后你用`\\<link>`引用，像下面这样：\n```html\n<link href=\"https://fonts.font.im/css?family=Kirang+Haerang\" rel=\"stylesheet\">\n```\n到此，我们说清楚了font-family后面跟两种值，字体族（一种字体）和通用字体族。中的前一种，字体族，其实也就表示一种字体，或系统自带、或自定义字体。\n\n### 通用字体族\n通用字体族名是一种备选机制，用于在指定的字体不可用时给出较好的字体。通用字体族名都是关键字，所以不可以加引号。 在`font-family`的值列表的末尾应该至少有一个通用字体族名。\n目前标准的5中通用字体族如下：\n+ serif，带衬线字体，笔画结尾有特殊的装饰线或衬线。比如宋体，撇捺竖等笔画带一些小尖尖。\n+ sans-serif，无衬线字体，即笔画结尾是平滑的字体。\n+ monospace，等宽字体，即字体中每个字宽度相同。比如某些字体中，字母i要比其他字母要窄一些，等宽字体的字母i和其他字母一样宽。\n+ cursive，草书字体或手写体。这种字体有的有连笔，有的还有特殊的斜体效果。因为一般这种字体都有一点连笔效果，所以会给人一种手写的感觉。\n+ fantasy，字体主要是那些具有特殊艺术效果的字体。\n\n![sans-serif无衬线字体和serif衬线字体的区别](//blogserver.jiaxuanlee.com/static/article-file/19/sans-serif无衬线字体和serif衬线字体.png)\n\n还有一些在[css提案](https://drafts.csswg.org/css-fonts-4/#generic-font-families) 中的通用字体族仅供了解：system-ui、math、emoji、fangsong。\n\n### 书写格式：font-family后面值的加不加引号\n我们看到font-family后面有的加引号，有的不加。\n\n首先说字体族（单字体），加不加引号都可以，但是名字中有空格时必须加引号\n字体族名可以包含空格，但包含空格时应该用引号，就像上面的`PingFang SC`在css中写就是`font-family: \"PingFang SC\"`，加引号；\n如果字体族名不包含空格，可以不用加引号，比如：`font-family: Arial`。\n所以在书写时字体族直接一律加上引号。\n\n然后通用字体族是一些特定的值上面讲到的5种，不能加引号。\n\n### 字体栈：font-family后面值表示的含义。\n`font-family: \"PingFang SC\",Arial,\"Microsoft YaHei\",sans-serif;`后面的几个字体族和最后一个通用字体族`sans-serif`组成了一个字体栈。\n字体栈是由于你无法保证你想在你的网页上使用的字体的可用性 (甚至一个网络字体可能由于某些原因而出错), 你可以提供一个字体栈 (font stack)，这样的话，浏览器就有多种字体可以选择了。\n那么字体栈是什么含义呢。我们像上面这样制定了字体栈时，前面的优先级高，后面的优先级低。\n> 浏览器在遇到每一个字时，都会去使用字体栈中优先级最高的字体去展示，如果无法展示，则找优先级第二高的，以此类推。到最后找到通用字体族的话，肯定能找到一种字体。\n\n注意，是每一个字，不是整个网站。比如：\"Welcome 小李\"，这句话，不是说要么全用宋体，要么全用平方，而是说每个字都要去看，可能英文是一种字体，中文是一种字体。每个字单独看。\n写一个简单的`<p>`里面写上英文中文数字的一个字符串，在chrome调试面板的`Elements面板`中选中这个p标签后，再右侧的`Computed菜单`中，拖到最下面会出现`Rendered Fonts`，可以查看一共使用了多少种字体，每种字体共展示了多少字符。\n\n下面截图展示\n![font-family调试查看](//blogserver.jiaxuanlee.com/static/article-file/19/font-family调试查看.png)\n如上所述：\n+ Chalkduster—Local file(7 glyphs)Chalkduster共7个字符\n+ Corsiva Hebrew—Local file(5 glyphs)Corsiva Hebrew共5个字符\n+ Songti SC—Local file(2 glyphs)Songti SC共2个字符\n\n### 字体图标\n现在基本都会使用字体图标，前面提到字体栈的时候我们强调过是针对每一个字符。现在你想一下，假设一个字母`A`，如果我指定了微软雅黑，那就是用微软雅黑展示`A`，是这样的，如果用其他的字字体，可能是那样的。那如果字符`A`，我用一个矢量图标去展示呢？\n这就是字体图标的原理，当然了，字体图标也不会用A去展示，而是一个utf8的编码去表示每一个字体图标。我们先准备好字体图标（通常是一个SVG文件）之后，我们可以用一些库去吧这个字体图标整理成css文件。\n常用的 ，国内有[阿里的icontfont](https://www.iconfont.cn/)，国外有[iconmoon](https://https://icomoon.io//)。', '2018-10-10 09:20:00', '2021-11-01 14:18:42');
INSERT INTO `article` VALUES (20, 1, '日期时间的格式导致Date对象在Safari浏览器Invalid Date 的问题', 1, 'new Date缩进我们常用的时间格式形如：2021-01-01 08:00:00，前半部分年月日是用', '## new Date\n    我们常用的时间格式形如：`2021-01-01 08:00:00`，前半部分年月日是用短线链接的。假设我们有如下代码：\n```js\n    let time = new Date(\'2021-01-01 08:00:00\');\n```\n    这样一行简单的代码，正常情况下，time变量是一个有效的Date对象。但是在ios和mac os的 Safari浏览器中，居然会有问题，time返回的是一个`Invalid Date`。\n\n### Safari浏览器识别年月日用短线链接的日期时间格式会有问题\n    在ios和mac os的 Safari浏览器中`new Date`中传入`2021-01-01 08:00:00`这种年月日用短线链接的日期时间格式，会出现无法识别的情况，从而会产生意想不到的问题。\n\n### 解决方案是换一种都能识别的格式就可以了\n    在ios和mac os的 Safari浏览器中把 `2021-01-01 08:00:00`换成`2021/01/01 08:00:00`格式就没问题了。\n    具体的操作就是可以`replace(\'-\',\'/\')`或者封装Date.prototype，统一收敛日期时间格式的处理和转换等。', '2021-01-21 11:21:00', '2021-01-21 11:21:00');
INSERT INTO `article` VALUES (21, 1, '使用Certbot将网站升级到HTTPS', 1, '缩进本文主要目的是简单说明一下如何利用Certbot将一个http的网站升级到https', '    本文主要目的是简单说明一下如何利用[Certbot](https://certbot.eff.org/)将一个http的网站升级到https的网站。\n    关于HTTPS网站的一些知识，在开始之前，简单的列一下（可能不详细、全面，但是有个大概的知识）：\n+ HTTPS证书，正规的很贵，很正式。我个人使用，无所谓到底有多安全、多正规，所以我用的是[Let\'s Encrypt](https://letsencrypt.org/)，是一个开源免费的https证书库\n    - 具体https证书的颁发机构和验证机制、还有[Let\'s Encrypt](https://letsencrypt.org/)的背后的原理，这里不再叙述。\n+ [Certbot](https://certbot.eff.org/)是[Let\'s Encrypt](https://letsencrypt.org/)官方推荐的一个直接在服务器上使用的一个工具。\n    - [Let\'s Encrypt](https://letsencrypt.org/)申请的证书是90天到期，证书到期之后需要重新申请。使用[Certbot](https://certbot.eff.org/)的话可以自动更新证书。其实是在你的系统中部署一个cron job或其他系统定时任务。\n    - [Certbot](https://certbot.eff.org/)除了帮你申请证书以外。还会做很多自动化的工作，方便快捷。\n\n### 1 我的http网站\n    我的网站部署在CentOS 8.3的linux服务器上；使用了Nginx搭建网站（前后端）；\n\n### 2 大致流程\n+ 确定自己的服务器版本。如果是CentOS的系统，可以执行命令：`cat /etc/centos-release`查看服务器版本。\n+ 安装certbot[官网教程](https://certbot.eff.org/lets-encrypt/centosrhel8-nginx)（我的链接是CentOS和Nginx的），请在页面顶部选择自己网站运行的系统和服务器（Nginx或者Apache或者其他的）。选择好之后下面的教程就是对应的步骤，直接照做就行了。\n    - 教程中会提示你要先安装snap(你可以理解为一个Linux的应用商店)，教程中链接点进去找到自己的系统版本的教程安装就行了[Snaps](https://snapcraft.io/docs/installing-snap-on-centos)（这里还是列的CentOS的教程）。\n+ 上面提到的教程的最后是使用Certbot的步骤，Certbot会自动的读取你的nginx的conf文件，然后找到你部署的网站的域名。然后你按照提示申请证书之后，还会自动帮你更新Nginx配置并重新启动Nginx。整个过程你不需要手动修改Nginx配置，关心证书安装到了什么位置，会不会自动更新证书有效期等等。Certbot都会自动帮你完成。这就是这个工具的意义，方便快捷。\n\n### 参考\n [Let\'s Encrypt](https://letsencrypt.org/)\n[Certbot](https://certbot.eff.org/)\n[Certbot的官网教程（CentOS 8 + Nginx）](https://certbot.eff.org/lets-encrypt/centosrhel8-nginx)', '2019-11-01 16:10:20', '2019-11-01 16:10:20');
INSERT INTO `article` VALUES (22, 1, 'Electron.js 开发应用举例', 1, '1 注意事项1.1 node版本缩进demo使用了Vite，所以开发时需要node版本不低于121.2 ', '## 1 注意事项\n### 1.1 node版本\n    demo使用了Vite，所以开发时需要node版本不低于12\n\n### 1.2 系统兼容性\n    Mac和Windows同样的功能或者api会有表现上的区别，请留意官网。本文不做过多介绍。\n    Mac系统只能打包Mac的桌面应用，Windows只能打包Windows的桌面应用。\n\n### 1.3 Electron版本问题\n    本文基于Electron 13+，老版本的Electron可能不是同样的架构和思路。网上资料查询问题时需要注意版本。\n\n### 1.4 技术栈\n[Vite](https://cn.vitejs.dev/) + [TypeScript](https://www.tslang.cn/) + [Vue 3](https://v3.cn.vuejs.org/) + [Electron](https://www.electronjs.org/)\n\n## 2 Electron + Vue 3 的架构\n![Electron+Vue3的架构示意图](https://blogserver.jiaxuanlee.com/static/article-file/22/Electron+Vue3的架构.png)\n\n## 3 主进程、渲染进程、预加载脚本(preload)\n    官方解释：[流程模型](https://www.electronjs.org/docs/tutorial/process-model)\n\n### 3.1 主进程\n    每个 Electron 应用都有一个单一的主进程，作为应用程序的入口点。 主进程在 Node.js 环境中运行，这意味着它具有 require 模块和使用所有 Node.js API 的能力。\n    为了使 Electron 的功能不仅仅限于对网页内容的封装，主进程也添加了自定义的 API 来与用户的作业系统进行交互。 Electron 有着多种控制原生桌面功能的模块，例如菜单、对话框以及托盘图标。\n\n### 3.2 渲染进程\n    可以简单理解为一个浏览器的标签页。\n    每个 Electron 应用都会为每个打开的 BrowserWindow ( 与每个网页嵌入 ) 生成一个单独的渲染器进程。 洽如其名，渲染进程负责 渲染 网页内容。 所以实际上，运行于渲染进程中的代码是须遵照网页标准的 (至少就目前使用的 Chromium 而言是如此) 。\n因此，一个浏览器窗口中的所有的用户界面和应用功能，都应与您在网页开发上使用相同的工具和规范来进行编写。渲染进程不具备直接使用 Node.js API 的能力。\n\n### 3.3 预加载脚本(preload)\n    预加载（preload）脚本包含了那些执行于渲染进程中，且先于网页内容开始加载的代码 ，并且这些代码具备直接使用 Node.js API 的能力。\n    由于预加载脚本与渲染进程共享同一个全局 Window 接口，并且可以访问 Node.js API，因此它通过在 window 全局中暴露任意您的网络内容可以随后使用的 API 来增强渲染进程。这个需要通过Electron提供的[contextBridge](https://www.electronjs.org/docs/api/context-bridge)对象的[exposeInMainWorld](https://www.electronjs.org/docs/api/context-bridge#contextbridgeexposeinmainworldapikey-api)方法将api或对象暴露给渲染器进程。\n\n### 3.4 进程间通信（IPC）\n    Electorn为了方便主进程和渲染进程之间通信封装了两个对象ipcMain和ipcRender，两个对象都是[EventEmitter（node）](https://nodejs.org/api/events.html#events_class_eventemitter) 实例，ipcMain和ipcRender传递参数使用的是[window.postMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)，所以传递参数就会有限制。详见[结构化克隆法](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)。比如vue3中的this.xxx(proxy封装的代理，就不能直接传，需要是对象字面量例如：`var myHonda = {color: \"red\", wheels: 4, engine: {cylinders: 4, size: 2.2}}; `。\n\n## 4 DEMO展示与讲解\n\n## 5 打包及安装\n    打包用到了[electron-builder](https://www.electron.build/)，Mac系统只能打包Mac的桌面应用，Windows只能打包Windows的桌面应用。\n    可以配置打包出来的icon作者等信心，其他更多配置自行查找配置项。\n    package.json的productName可以配置打包的App名。\n    打包过程可能需要翻墙，请注意控制台的输出信息。\n\n## 6 思考&总结\n## 6.1 优点\n    样式和交互：使用web样式和交互开发桌面应用，比传统的方式快捷简单了很多，传统的QT或者MFC或者C#等方式若想达到理想的效果，需要在样式上费很大功夫，而用web实现就很简单。\n    技术栈：更偏JS（大前端）\n\n## 6.2 缺点\n    性能：无法媲美原生。某些高性能的功能只能通过c++或其他语言实现库，然后通过node去调用的方式来完成，比如批量读写大文件。\n    兼容性：需要针对mac和windows做不同处理，\n\n## 6.3 复杂点\n    主进程和渲染进程通信通过ipcMain和ipcRender交互才能调用桌面的api，可能需要封装通用化的处理逻辑。\n\n## 6.4 总结\n    通过electron可以实现一些复杂性一般的功能，并且这个过程很容易。electron还有很多功能本文并没提到，比如在线更新app等。但是若想实现复杂的功能或许需要和传统的实现方式进行有机的结合。', '2021-11-05 16:30:00', '2021-11-08 17:17:00');
INSERT INTO `article` VALUES (23, 1, '图片教程', 1, 'https://mp.weixin.qq.com/s/LN-fBf-RigSfS_XtU_19JQ?scene=25#wechat_redirect', 'https://mp.weixin.qq.com/s/LN-fBf-RigSfS_XtU_19JQ?scene=25#wechat_redirect', '2023-04-07 10:00:00', '2023-04-07 10:00:00');
COMMIT;

-- ----------------------------
-- Table structure for articles_tags_relation
-- ----------------------------
DROP TABLE IF EXISTS `articles_tags_relation`;
CREATE TABLE `articles_tags_relation` (
  `relation_id` int(1) unsigned NOT NULL AUTO_INCREMENT COMMENT '关系id，自增',
  `relation_article` int(1) unsigned DEFAULT NULL COMMENT '文章id，外键',
  `relation_tag` int(1) unsigned DEFAULT NULL COMMENT '标签id，外键',
  PRIMARY KEY (`relation_id`),
  KEY `fk_relation_article` (`relation_article`),
  KEY `fk_relation_tag` (`relation_tag`),
  CONSTRAINT `fk_relation_article` FOREIGN KEY (`relation_article`) REFERENCES `article` (`article_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_relation_tag` FOREIGN KEY (`relation_tag`) REFERENCES `tag` (`tag_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=489 DEFAULT CHARSET=utf8mb4 COMMENT='文章和标签的关系表：用于存储文章和标签的多对多关系';

-- ----------------------------
-- Records of articles_tags_relation
-- ----------------------------
BEGIN;
INSERT INTO `articles_tags_relation` VALUES (55, 2, 8);
INSERT INTO `articles_tags_relation` VALUES (56, 2, 36);
INSERT INTO `articles_tags_relation` VALUES (57, 2, 37);
INSERT INTO `articles_tags_relation` VALUES (58, 3, 8);
INSERT INTO `articles_tags_relation` VALUES (59, 3, 37);
INSERT INTO `articles_tags_relation` VALUES (60, 3, 36);
INSERT INTO `articles_tags_relation` VALUES (210, 6, 2);
INSERT INTO `articles_tags_relation` VALUES (211, 6, 38);
INSERT INTO `articles_tags_relation` VALUES (273, 10, 36);
INSERT INTO `articles_tags_relation` VALUES (274, 10, 37);
INSERT INTO `articles_tags_relation` VALUES (275, 10, 8);
INSERT INTO `articles_tags_relation` VALUES (282, 11, 36);
INSERT INTO `articles_tags_relation` VALUES (283, 11, 37);
INSERT INTO `articles_tags_relation` VALUES (284, 11, 8);
INSERT INTO `articles_tags_relation` VALUES (381, 13, 41);
INSERT INTO `articles_tags_relation` VALUES (382, 13, 8);
INSERT INTO `articles_tags_relation` VALUES (383, 12, 8);
INSERT INTO `articles_tags_relation` VALUES (384, 12, 41);
INSERT INTO `articles_tags_relation` VALUES (409, 15, 36);
INSERT INTO `articles_tags_relation` VALUES (410, 15, 37);
INSERT INTO `articles_tags_relation` VALUES (411, 15, 8);
INSERT INTO `articles_tags_relation` VALUES (444, 20, 8);
INSERT INTO `articles_tags_relation` VALUES (445, 20, 36);
INSERT INTO `articles_tags_relation` VALUES (446, 19, 9);
INSERT INTO `articles_tags_relation` VALUES (447, 19, 43);
INSERT INTO `articles_tags_relation` VALUES (448, 18, 36);
INSERT INTO `articles_tags_relation` VALUES (449, 18, 8);
INSERT INTO `articles_tags_relation` VALUES (450, 18, 22);
INSERT INTO `articles_tags_relation` VALUES (451, 18, 37);
INSERT INTO `articles_tags_relation` VALUES (452, 14, 36);
INSERT INTO `articles_tags_relation` VALUES (453, 14, 37);
INSERT INTO `articles_tags_relation` VALUES (454, 14, 8);
INSERT INTO `articles_tags_relation` VALUES (455, 7, 8);
INSERT INTO `articles_tags_relation` VALUES (456, 7, 36);
INSERT INTO `articles_tags_relation` VALUES (457, 7, 39);
INSERT INTO `articles_tags_relation` VALUES (458, 7, 40);
INSERT INTO `articles_tags_relation` VALUES (459, 4, 8);
INSERT INTO `articles_tags_relation` VALUES (460, 4, 37);
INSERT INTO `articles_tags_relation` VALUES (461, 4, 36);
INSERT INTO `articles_tags_relation` VALUES (462, 1, 34);
INSERT INTO `articles_tags_relation` VALUES (463, 1, 35);
INSERT INTO `articles_tags_relation` VALUES (464, 21, 14);
INSERT INTO `articles_tags_relation` VALUES (465, 21, 22);
INSERT INTO `articles_tags_relation` VALUES (466, 21, 44);
INSERT INTO `articles_tags_relation` VALUES (467, 21, 45);
INSERT INTO `articles_tags_relation` VALUES (474, 22, 47);
INSERT INTO `articles_tags_relation` VALUES (475, 22, 46);
INSERT INTO `articles_tags_relation` VALUES (476, 22, 7);
INSERT INTO `articles_tags_relation` VALUES (477, 5, 8);
INSERT INTO `articles_tags_relation` VALUES (478, 5, 37);
INSERT INTO `articles_tags_relation` VALUES (479, 5, 36);
INSERT INTO `articles_tags_relation` VALUES (480, 8, 8);
INSERT INTO `articles_tags_relation` VALUES (481, 8, 37);
INSERT INTO `articles_tags_relation` VALUES (482, 8, 36);
INSERT INTO `articles_tags_relation` VALUES (483, 9, 36);
INSERT INTO `articles_tags_relation` VALUES (484, 9, 37);
INSERT INTO `articles_tags_relation` VALUES (485, 9, 8);
INSERT INTO `articles_tags_relation` VALUES (486, 23, 8);
INSERT INTO `articles_tags_relation` VALUES (487, 23, 43);
INSERT INTO `articles_tags_relation` VALUES (488, 23, 9);
COMMIT;

-- ----------------------------
-- Table structure for author
-- ----------------------------
DROP TABLE IF EXISTS `author`;
CREATE TABLE `author` (
  `author_id` int(1) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `author_nickname` varchar(7) NOT NULL COMMENT '作者昵称，唯一',
  `author_email` varchar(25) NOT NULL COMMENT '作者的邮箱，唯一标识',
  `author_password` varchar(15) NOT NULL COMMENT '密码',
  `author_motto` varchar(25) DEFAULT NULL COMMENT '作者座右铭',
  `author_is_active` tinyint(1) NOT NULL DEFAULT '1' COMMENT '账户是否启用：1启用，0不启用',
  `author_device_uuid` varchar(36) DEFAULT NULL COMMENT '作者设备的uuid',
  `author_lee_token` varchar(32) DEFAULT NULL COMMENT '登录的token',
  PRIMARY KEY (`author_id`),
  UNIQUE KEY `index_id_nn_email` (`author_id`,`author_nickname`(3),`author_email`(12)) COMMENT '作者id、昵称、邮箱'
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='作者表：方便以后扩展（1、作者邮箱：author_email；2、作者昵称：author_nickname；3、作者密码：author_password；4、作者座右铭：author_motto）';

-- ----------------------------
-- Records of author
-- ----------------------------
BEGIN;
INSERT INTO `author` VALUES (1, '阁主', 'lijiaxuan0829@sina.com', '19491001', '相思难表，梦魂无据，惟有归来是', 1, '6D100FBD-D174-43F4-AE60-C5731E376F5F', '315025B09F5CB7544C6D1E867EFDFE0D');
COMMIT;

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `ctg_id` int(1) unsigned NOT NULL AUTO_INCREMENT COMMENT '类别id，自增',
  `ctg_name` varchar(8) NOT NULL COMMENT '类别名称，限制长度',
  PRIMARY KEY (`ctg_id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COMMENT='类别表：用于文章大方向的分类（技术、生活等）';

-- ----------------------------
-- Records of category
-- ----------------------------
BEGIN;
INSERT INTO `category` VALUES (1, '技术');
INSERT INTO `category` VALUES (2, '生活');
INSERT INTO `category` VALUES (3, '其他');
COMMIT;

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `tag_id` int(1) unsigned NOT NULL AUTO_INCREMENT COMMENT '标签id，自增',
  `tag_category` int(1) unsigned DEFAULT '1' COMMENT '外键，标签所属类型的id',
  `tag_name` varchar(30) NOT NULL COMMENT '标签名字',
  PRIMARY KEY (`tag_id`),
  KEY `index_ctg_name` (`tag_category`,`tag_name`),
  CONSTRAINT `fk_tag_ctg` FOREIGN KEY (`tag_category`) REFERENCES `category` (`ctg_id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=48 DEFAULT CHARSET=utf8mb4 COMMENT='标签表：博客的所有标签（1、标签名称：tag_name；2、标签创建时间：tag_createtime;3、标签所属类别：tag_category）';

-- ----------------------------
-- Records of tag
-- ----------------------------
BEGIN;
INSERT INTO `tag` VALUES (32, 1, 'AI');
INSERT INTO `tag` VALUES (3, 1, 'Angular');
INSERT INTO `tag` VALUES (9, 1, 'CSS');
INSERT INTO `tag` VALUES (43, 1, 'CSS教程');
INSERT INTO `tag` VALUES (15, 1, 'Docker');
INSERT INTO `tag` VALUES (20, 1, 'Elasticsearch');
INSERT INTO `tag` VALUES (47, 1, 'Electron');
INSERT INTO `tag` VALUES (11, 1, 'ES6');
INSERT INTO `tag` VALUES (12, 1, 'ES7+');
INSERT INTO `tag` VALUES (4, 1, 'Flutter');
INSERT INTO `tag` VALUES (18, 1, 'Go');
INSERT INTO `tag` VALUES (10, 1, 'HTML');
INSERT INTO `tag` VALUES (22, 1, 'HTTP');
INSERT INTO `tag` VALUES (44, 1, 'HTTPS');
INSERT INTO `tag` VALUES (40, 1, 'Hybrid');
INSERT INTO `tag` VALUES (17, 1, 'IDEA');
INSERT INTO `tag` VALUES (8, 1, 'JavaScript');
INSERT INTO `tag` VALUES (39, 1, 'JavaScript&Native');
INSERT INTO `tag` VALUES (37, 1, 'JS教程');
INSERT INTO `tag` VALUES (36, 1, 'JS知识要点');
INSERT INTO `tag` VALUES (13, 1, 'Linux');
INSERT INTO `tag` VALUES (45, 1, 'Linux运维');
INSERT INTO `tag` VALUES (19, 1, 'MySQL');
INSERT INTO `tag` VALUES (14, 1, 'Nginx');
INSERT INTO `tag` VALUES (33, 1, 'Python');
INSERT INTO `tag` VALUES (1, 1, 'React');
INSERT INTO `tag` VALUES (5, 1, 'React Native');
INSERT INTO `tag` VALUES (23, 1, 'TCP/IP');
INSERT INTO `tag` VALUES (7, 1, 'TypeScript');
INSERT INTO `tag` VALUES (2, 1, 'Vue');
INSERT INTO `tag` VALUES (38, 1, 'VUE 知识点');
INSERT INTO `tag` VALUES (46, 1, 'Vue3');
INSERT INTO `tag` VALUES (42, 1, 'Vue源码解析');
INSERT INTO `tag` VALUES (6, 1, 'Webpack');
INSERT INTO `tag` VALUES (29, 1, '分布式');
INSERT INTO `tag` VALUES (41, 1, '前端面试题');
INSERT INTO `tag` VALUES (16, 1, '开发环境');
INSERT INTO `tag` VALUES (25, 1, '操作系统');
INSERT INTO `tag` VALUES (31, 1, '数据结构');
INSERT INTO `tag` VALUES (30, 1, '算法');
INSERT INTO `tag` VALUES (26, 1, '编译原理');
INSERT INTO `tag` VALUES (24, 1, '计算机网络');
INSERT INTO `tag` VALUES (21, 1, '设计模式');
INSERT INTO `tag` VALUES (28, 1, '高并发');
INSERT INTO `tag` VALUES (34, 3, 'lee-blog');
INSERT INTO `tag` VALUES (35, 3, 'lee-markdown');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
